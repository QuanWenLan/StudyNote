## 秘籍

### 对于二进制转换类的题目   

> **对于一般性的进制转换题目，只需要不断地对columnNumber 进行 % 运算取得最后一位，然后对 columnNumber 进行 / 运算，将已经取得的位数去掉，直到 columnNumber 为 0 即可.**
>
> 一般性的进制转换题目无须进行额外操作，是因为我们是在「每一位数值范围在 [0,x)」的前提下进行「逢 x 进一」。
>
> 但本题需要我们将从 1 开始，因此在执行「进制转换」操作前，我们需要先对 columnNumber 执行减一操作，从而实现整体偏移。
>
> ```java
> class Solution {
>     public String convertToTitle(int cn) {
>         StringBuilder sb = new StringBuilder();
>         while (cn > 0) {
>             cn--;
>             sb.append((char)(cn % 26 + 'A'));
>             cn /= 26;
>         }
>         sb.reverse();
>         return sb.toString();
>     }
> }
> ```
>
> 作者：AC_OIer
> 链接：https://leetcode-cn.com/problems/excel-sheet-column-title/solution/gong-shui-san-xie-cong-1-kai-shi-de-26-j-g2ur/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

上述方法同样适用于十进制，二进制等。



----

### 解题三部曲

##### **1. 看懂题目**

看懂题目。有的题目很直接，直接告诉你要解决的问题是什么，题目本身甚至都包含了对应的数据结构和需要用到的算法；有的题目很隐晦，看了半天不知道它到底要解决什么问题，可以用什么算法和数据结构来解。所以，看到题目后，一定要先确保自己理解清楚了。

我的一个经验是，拿到一个题目后，看5分钟，如果5分钟之内看不懂，我就mark 下来，留到后面再做，要不很影响刷题的心情。

不过就leetcode 来说，这样的题目不多。基本都能在再5分钟内看懂。

##### **2.分析，推导解法**

分析推导题目的解法。

这个步骤要有意识地单独拎出来，不要跟编码步骤混淆在一起。也就是说，你在分析推导题目解法的时候，不要去想任何实现相关地事情，不用去想代码怎么写，不用去想要用什么库，定义什么变量，用多少层循环，都不要想，就想着在逻辑上，这道题目要怎么解。

这样做可以极大地降低你的心智负担，使你高效地想出题目的解法。对于如何将想法变成代码，可以留在下一个步骤，单独来进行。

##### **3.将思路转换为代码**

当你确定题目都已经理解，并且分析推导出了题目的解法后，你才开始来思考如何将自己的思路转换成代码。是地，将思路转换成代码，可以是一个单独地步骤，在实际工作中，其实也是很重要的一个能力。

有时，将一个思路转换成算法是很容易且自然的；但有时，有些思路转换成代码，是很有难度的事情。

或者你有体会，分析推导只用了不到十分钟，结果代码写了半小时还写不完整。

怎么定义变量，保存状态，用递归，还是用循环加辅助数据结构等等，都是将思路转换成代码要做的事情。

这个能力也需要刻意地去练习。

作者：GitHubPorn
链接：https://www.zhihu.com/question/353442003/answer/929509045
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

---



### 递归分析三部曲 

##### 1 确定递归函数的参数和返回类型

（**如果需要遍历整颗树，递归函数就不能有返回值。如果需要遍历某一条固定路线，递归函数就一定要有返回值！**）

##### 2 确定终止条件

##### 3 确定单层递归时的逻辑

> 如：[112 路径总和](https://leetcode.cn/problems/path-sum/)，[找树左下角的值](https://mp.weixin.qq.com/s/MH2gbLvzQ91jHPKqiub0Nw)
>

---

### 二叉树

#### 写递归算法的秘诀  

https://labuladong.gitee.io/algo/1/12/

写递归算法的关键是要明确函数的【定义】是什么，然后相信这个定义，利用这个定义推到最终结果，绝不要跳入递归的细节。（跳入了就出不来了。。。。）  

用一个具体的例子来说，比如说让你计算一颗二叉树共有几个节点： 

```java
// 定义：count(root) 返回以 root 为根的树有多少节点
int count(TreeNode root) {
    // base case
    if (root == null) return 0;
    // 自己加上子树的节点数就是整棵树的节点数
    return 1 + count(root.left) + count(root.right);
}
```

这个问题非常简单，大家应该都会写这段代码，`root` 本身就是一个节点，加上左右子树的节点数就是以 `root` 为根的树的节点总数。

左右子树的节点数怎么算？其实就是计算根为 `root.left` 和 `root.right` 两棵树的节点数呗，按照定义，递归调用 `count` 函数即可算出来。

---

**写树相关的算法，简单说就是，先搞清楚当前** **`root`** **节点「该做什么」以及「什么时候做」，然后根据函数定义递归调用子节点**，递归调用会让孩子节点做相同的事情。

所谓**「该做什么」就是让你想清楚写什么代码能够实现题目想要的效果**，**所谓「什么时候做」，就是让你思考这段代码到底应该写在前序、中序还是后序遍历的代码位置上**。   

> 二叉树题目的一个难点就是，如何把题目的要求细化成每个节点需要做的事情









