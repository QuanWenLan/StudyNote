### 微服务(dubbo、zookeeper、springcloud、ES)

#### 微服务

##### 用几个词概括一下微服务的特点

单一职责、 团队独立、 技术独立、 前后端分离、 数据库分离、独立部署、 服务治理

#### dubbo

[Dubbo面试题（总结最全面的面试题）](https://juejin.cn/post/6844904127076499463)

##### springcloud 和 dubbo 的区别

##### 服务调用超时会怎么样？

- dubbo 在调用服务不成功时，默认是会重试两次。这个配置可以进行修改，有很多属性可以修改，协议，超时时间等。

```java
import org.apache.dubbo.rpc.RpcContext;
import org.apache.dubbo.config.annotation.Service;
/**
 * @Service 注解是dubbo的注解，不是spring的，可以对其设置一个调用的超时时间：timeout = 2000。
 * 还可以设置其他的一些属性
 * 服务接口实现类配置：
 * @Service(interfaceClass = YourService.class)：指定服务接口。
 * 超时配置：
 * @Service(timeout = 3000)：设置服务的超时时间（毫秒）。
 * 版本配置：
 * @Service(version = "1.0")：指定服务的版本号。
 * 集群配置：
 * @Service(cluster = "failfast")：设置集群容错模式，例如 failfast、failsafe、failover 等。
 */
@Service(timeout = 2000, retries = 2)
public class DemoServiceImpl implements DemoService {
    @Override
    public String sayHello(String name) {
        log.info("Hello " + name + ", request from consumer: " + RpcContext.getContext().getRemoteAddress());
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "Hello " + name + ", response from provider: " + RpcContext.getContext().getLocalAddress();
    }
}
```

##### dubbo和open feign的区别

dubbo

1. **通信协议：** Dubbo 使用 RPC（远程过程调用）协议进行通信，支持多种序列化协议，如Hessian、JSON等。
2. **服务治理：** Dubbo 提供了强大的服务治理和负载均衡能力，包括服务注册、发现、路由、负载均衡等。
3. **传输协议：** Dubbo 可以使用多种传输协议，包括dubbo协议、http协议等。
4. **中心化配置：** Dubbo 支持中心化的配置管理，可以通过注册中心配置服务提供者和消费者的一些行为。
5. **异步调用：** Dubbo 支持异步调用，可以通过异步方式提高系统的并发能力。

openFeign

1. **通信协议：** OpenFeign 基于 HTTP 协议，使用了 Spring Cloud 的服务治理功能。
2. **服务治理：** OpenFeign通常与Spring Cloud一起使用，利用Eureka或其他服务注册中心进行服务的发现和治理。
3. **传输协议：** OpenFeign 主要基于 HTTP，通常用于微服务之间的 HTTP 通信。
4. **中心化配置：** OpenFeign 常常与 Spring Cloud Config 等工具一起使用，实现中心化的配置管理。
5. **声明式REST调用：** OpenFeign 提供了声明式的 REST 调用方式，通过简单的注解，开发者可以轻松定义和调用服务。

##### dubbo的 SPI 机制

简单来说就是自己实现一个负载均衡策略，然后将实现类放入到 `META-INF/dubbo/org.apache.dubbo.rpc.cluster.LoadBalance` 配置文件中，在程序运行过程中读取配置文件，通过反射加载实现类。

##### 负载均衡（轮询）

###### Weighted RandomLoadBalance 根据权重随机选择（对加权随机算法的实现）

这是Dubbo默认采用的一种负载均衡策略。假如有两个提供相同服务的服务器 S1,S2，S1的权重为7，S2的权重为3，我们把这些权重值分布在坐标区间会得到：S1->[0, 7) ，S2->[7, 10)。我们生成[0, 10) 之间的随机数，随机数落到对应的区间，我们就选择对应的服务器来处理请求。

缺点：存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。

###### LeastActive LoadBalance 最小活跃负载均衡

初始状态下所有服务提供者的活跃数均为 0，每收到一个请求后，对应的服务提供者的活跃数 +1，当这个请求处理完之后，活跃数 -1。**Dubbo 就认为谁的活跃数越少，谁的处理速度就越快，性能也越好，**。

**多个服务提供者的活跃数相等怎么办**？**再走一遍 RandomLoadBalance**。

使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大；相对的，处理能力越强的节点，处理更多的请求。

###### ConsistentHash LoadBalance 一致性 hash 负载均衡策略 

在分库分表、各种集群中就经常使用这个负载均衡策略，`ConsistentHashLoadBalance` 中没有权重的概念，具体是哪个服务提供者处理请求是由你的请求的参数决定的，也就是说相同参数的请求总是发到同一个服务提供者。

<img src="media/images/image-20230322160907603.png" alt="image-20230322160907603" style="zoom:50%;" />

Dubbo 为了避免数据倾斜问题（节点不够分散，大量请求落到同一节点），还引入了虚拟节点的概念。通过虚拟节点可以让节点更加分散，有效均衡各个节点的请求量。

<img src="media/images/image-20230322160945846.png" alt="image-20230322160945846" style="zoom:50%;" />

当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。

###### RoundRobinLoadBalance 加权轮询负载均衡

**轮询就是把请求依次分配给每个服务提供者**。加权轮询就是在轮询的基础上，**让更多的请求落到权重更大的服务提供者上**。比如假如有两个提供相同服务的服务器 S1,S2，S1的权重为7，S2的权重为3。

如果我们有 10 次请求，那么 7 次会被 S1处理，3次被 S2处理。

但是，如果是 `RandomLoadBalance` 的话，很可能存在10次请求有9次都被 S1 处理的情况（概率性问题）。

缺点：同样存在慢的提供者累积请求的问题