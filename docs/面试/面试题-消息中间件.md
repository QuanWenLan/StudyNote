### 消息中间件

[RabbitMQ面试题](https://juejin.cn/post/6844904125935665160) 

##### 为什么用消息队列中间件、以及缺点

1. **通过异步处理提高系统性能（减少响应所需时间）**
2. **削峰/限流**
3. **降低系统耦合性**
4. **实现分布式事务**

缺点

- 系统可用性降低
- 系统复杂程度提高
- 一致性问题

##### 消费队列如何防止重复消费以及哪个地方会出现问题

防止消费者重复消费

1. 使用Mysql的唯一索引约束来解决这个问题
2. 使用redis的setnx指令来解决，第一次setnx返回true,第二次就返回false
3. 使用去重表来解决，然后定时清除去重表的数据即可
4. 当然了，处理都需要考虑业务的问题，从业务方面区进行去重

注：RocketMQ给每个消息分配了一个messageId,可以一定程度上用这个值来处理，但是还是有问题，假设客户端同一个消息发了两个订单，但是messageId是一样的，这样就有问题了

[【RabbitMQ】RabbitMQ如何做到保证消息100%不丢失？](https://blog.csdn.net/bookssea/article/details/123119980) 

##### MQ如何保证消息顺序

全局有序和局部有序：MQ只需要保证局部有序即可

RocketMQ是如何保证有序的？

情况一：当topic只有一个queue的时候，那么就是天然有序的

情况二：有多个queue就需要进行处理

1. 生产者使用select把需要有序的消息放到同一个queue中
2. 消费者使用oredrly横向取消息进行处理，默认情况下是从多个queue取消息的，横向取那么就有序了，拿之前需要锁队列，是为了生产者短时间不能再发送消息？同时其他消息者就不能消费了，估计是这样

RabbitMQ:

- 保证exchange只有一个队列，并且一个队列只对应一个消费者才可以保证消息有序被处理。

Kafka：

- 保证一个topic只有一个partition分区即可，在多个partition的情况下，可以把需要有序的一组消息路由到同一个partition分区下面即可

##### 如何保证RabbitMQ消息的可靠传输

**生产者丢失消息**：从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。

**消息队列丢数据**：消息持久化。

**消费者丢失消息**：消费者丢数据一般是因为采用了自动确认消息模式，改为手动确认消息。

##### 消息队列对比

![image-20230313145323449](media/images/image-20230313145323449.png)



[详解ＭＱ消息队列及四大主流ＭＱ的优缺点 - 墨天轮 (modb.pro)](https://www.modb.pro/db/542085) 

##### 订单超时自动关闭

原理：下单投放消息到A交换机（过期时间30分钟），**消息到aa队列（绑定死信交换机）**，**不设置aa队列的消费者**(故此消息一直未消费)。

30分钟后，过期消息投递到死信交换机，死信队列，由死信消费者消费，判断订单id是否支付，执行业务逻辑，支付->return；未支付->关闭订单，返还库存。

[RabbitMQ实现订单30分钟超时自动关闭](https://blog.csdn.net/zhangshengqiang168/article/details/104718979) 

##### rabbitmq 消息不消费问题

- 看服务端有没有连接上消息队列 （https://blog.csdn.net/qq_33036061/article/details/106634425）
- 检查队列绑定的路由器是不是一致
- 查看接口，是否被调用到
- 消费端是否有进行手动确认，如果有设置手动，需要手动ack（相关链接博客：[线上RabbitMQ消息不消费问题](https://juejin.cn/post/7052196492622168072)）

一种现象：消费者接收不到MQ的消费数据，MQ管理后台数据阻塞。

问题：阻塞的队列（queue）找不到消费者（consumer）服务器。

##### 消息堆积的问题（消费者的速度与生产者发送消息的速度是不一致）

##### 导致的死信的几种原因？

DLX，全称为 Dead-Letter-Exchange，死信交换器，死信邮箱。当消息在一个队列中变成死信 (dead message) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。

- 消息被拒（Basic.Reject /Basic.Nack) 且 requeue = false。
- 消息TTL过期。
- 队列满了，无法再添加。

##### 优先级队列？

优先级高的队列会先被消费。可以通过x-max-priority参数来实现。当消费速度大于生产速度且Broker没有堆积的情况下，优先级显得没有意义。

##### RabbitMQ中消息可能有的几种状态

https://juejin.cn/post/6844904192146931720

alpha: 消息内容(包括消息体、属性和 headers) 和消息索引都存储在内存中 。

beta: 消息内容保存在磁盘中，消息索引保存在内存中。

gamma: 消息内容保存在磁盘中，消息索引在磁盘和内存中都有 。

delta: 消息内容和索引都在磁盘中 。

##### 消息基于什么传输？

[RabbitMQ面试题（总结最全面的面试题）](https://juejin.cn/post/6844904125935665160)

由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。

##### 消息持久化

处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。

那么如何持久化呢？

这里顺便说一下吧，其实也很容易，就下面两步

​	1. 将queue的持久化标识durable设置为true,则代表是一个持久的队列

​	2. 发送消息的时候将deliveryMode=2

这样设置以后，即使rabbitMQ挂了，重启后也能恢复数据。

##### 为什么不应该对所有的 message 都使用持久化机制？

首先，必然导致性能的下降，因为写磁盘比写 RAM 慢的多，message 的吞吐量可能有 10 倍的差距。

其次，message 的持久化机制用在 RabbitMQ 的内置 cluster 方案时会出现“坑爹”问题。矛盾点在于，若 message 设置了 persistent 属性，但 queue 未设置 durable 属性，那么当该 queue 的 owner node 出现异常后，在未重建该 queue 前，发往该 queue 的 message 将被 blackholed ；若 message 设置了 persistent 属性，同时 queue 也设置了 durable 属性，那么当 queue 的 owner node 异常且无法重启的情况下，则该 queue 无法在其他 node 上重建，只能等待其 owner node 重启后，才能恢复该 queue 的使用，而在这段时间内发送给该 queue 的 message 将被 blackholed 。

所以，是否要对 message 进行持久化，需要综合考虑性能需要，以及可能遇到的问题。若想达到 100,000 条/秒以上的消息吞吐量（单 RabbitMQ 服务器），则要么使用其他的方式来确保 message 的可靠 delivery ，要么使用非常快速的存储系统以支持全持久化（例如使用 SSD）。另外一种处理原则是：仅对关键消息作持久化处理（根据业务重要程度），且应该保证关键消息的量不会导致性能瓶颈。





