> 学习：极客时间---《MySQL实战45讲》

## 事务到底是隔离的还是不隔离的 

[上一篇](./07行锁功过：怎么减少行锁对性能的影响.md) 

在第三篇 [事务隔离](./03事务隔离.md) 中事务隔离级别时候提到过，**如果是可重复读隔离级别，事务 T 启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数据，事务 T 看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响**。  

但是在 [上一篇](./07行锁功过：怎么减少行锁对性能的影响.md) 中讲行锁的时候又提到，一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它又不能这么超然了，会被锁住，进入等待状态（是指A更新，B 查询然后更新么？）。**问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？**  

如下面例子：

```mysql
mysql> CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
insert into t(id, k) values(1,1),(2,2);
```

![image-20210716150409654](media/images/image-20210716150409654.png)

 													事务 A、B、C的执行流程 

**begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。**如果你想要马上启动一个事务，可以使用 `start transaction with consistent snapshot` 这个命令。

> 第一种启动方式，**一致性视图是在执行第一个快照读语句时创建的**；也就是执行第一个语句时创建的。
>
> 第二种启动方式，**一致性视图是在执行 start transaction with consistent snapshot 时创建的**。

没有特别说明都是默认`autocommit = 1`。  

> 事务自动提交设置，默认为1，即除非显示声明一个事务的开始，否则每一个查询都会被当做独立的事务被处理

在这个例子中，事务 C 没有显式地使用 begin/commit，表示这个 update 语句本身就是一个事务，语句完成的时候会自动提交。事务 B 在更新了行之后查询 ; 事务 A 在一个只读事务中查询，并且时间顺序上是在事务 B 的查询之后。

这时，如果我告诉你**事务 B 查到的 k 的值是 3，而事务 A 查到的 k 的值是 1，你是不是感觉有点晕**呢？（晕球了）  

> 自己理解：事务A的一致性视图执行第一句就有了，后面查询应该都是1，其他事务提交之后，查询应该也是1，出现幻读。事务B的一致性也是执行第一句就有了，这时应该也是 1，应该和A一样才对，更新完应该是2。事务C就正常更新为2了。并不是想的这样，哈哈哈

在MySQL里，有两个“视图”的概念：  

- 一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。
- 另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，**用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现**。

**它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据**。  

