> 被问到的一些知识点，后面完善一下

#### JAVA基础

1. 标识符

2. 拆箱和包装

3. 线程的状态之间的转换

4. 构造器显示调用，static代码块执行顺序，初始化顺序等。

5. static关键字

6. 形参实参，包装类参数，基本类型参数

7. switch case的穿透（坑）

8. 线程的run()方法和没有使用start()方法的差别。

9. 方法传递参数（引用类型、基本类型），在方法里面修改参数的值，实参的变化

10. 单例模式的定义（手写）

11. hashmap的原理，什么时候重写hashcode()和equals()方法

12. hashmap为什么是8转成树结构，怎么转换的

13. try catch finally中return 代码返回位置不一样，返回什么结果

14. try catch finally 里面自定义异常代码块，catch的应该是哪个

15. 子类父类构造器初始化顺序

16. Class a = new Class();Class b = new Class(); a==b?输出什么。为什么？Class对象考察

17. 数据库的基本语句

18. ArrayList和LinkedList区别

19. hashmap（不同步）和concurrentHashMap（同步）

20. jsp的一些内置对象

21. 分布式

    dubbo、zookeeper、springcloud、springboot

    

#### 数据库

1. @Transaction 什么时候失效

2. 两千万数据 B+ 树高度是多少？

3. 聚簇索引

4. index 索引为啥查询很快

> B+ 树的查询效率，log n，相比全表扫描当然很快。

5. mysql 索引失效
6. MySQL索引的结构、如何创建索引、创建索引遵循的原则、sql优化
7. 事务

#### 多线程

1. 多线程，notify()和notifyAll()的区别，以及synchronized关键字

#### JVM

什么时候发生 Minor GC？

> 当 eden 区满了的时候触发



#### spring

1. 静态代理和动态代理区别
2. spring mvc的原理
3. spring事务：注解、声明式

#### 中间件

#### 网络

1. TCP/IP协议，三次握手，四次挥手、TCP和UDP的区别
2. get post 方法区别
3. 网络协议七层模型（对应的有哪些协议）

#### 业务

1. 订单如何防止重复提交，如何控制两边的事务

   防止重复提交：[8种方案解决重复提交问题 - Java知音号 - 博客园 (cnblogs.com)](https://www.cnblogs.com/javazhiyin/p/11407140.html) 

   > 1 js弹出一个提交的loading弹窗，正在创建xxx
   >
   > 2 利用 redis 进行
   >
   > （1）具体将订单编号添加到redis缓存中，如果再次提交，在redis中查询到了则提示，订单正在创建或者其他的状态信息
   >
   > （2）使用redis的原子性操作命令
   >
   > - 每次创建订单新建一个 order id 为key的计数器，然后 +1，如果 > 1，则说明有操作正在执行；如果=1，则说明可以提交订单。
   > - 操作结束，删除这个订单key
   >
   > 3 token 机制解决

2. 设计一些页面 v-if,v-show

3. 如何对接第三方支付接口的，如何和测试联调，分布式事务

4. 生产环境出现了bug如何处理

5. 设计一个秒杀系统（redis 和 消息队列）

180.163.150.34  translate.googleapis.com

#### Spring 可能面试题总结

##### 1 spring 中使用到的模式

- 工厂模式

- 建造者模式


```java 
// 加载 xml 文件，建造者模式+工厂模式使用。 org.springframework.beans.factory.xml.DefaultDocumentLoader#loadDocument 
public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,
                             ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {

    DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);
    if (logger.isTraceEnabled()) {
        logger.trace("Using JAXP provider [" + factory.getClass().getName() + "]");
    }
    DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
    return builder.parse(inputSource);
}
```

- 模板方法模式

```java 
//org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions, 这里的 root  是 <beans xxxx></beans>
protected void doRegisterBeanDefinitions(Element root) {
		// Any nested <beans> elements will cause recursion in this method. In
		// order to propagate and preserve <beans> default-* attributes correctly,
		// keep track of the current (parent) delegate, which may be null. Create
		// the new (child) delegate with a reference to the parent for fallback purposes,
		// then ultimately reset this.delegate back to its original (parent) reference.
		// this behavior emulates a stack of delegates without actually necessitating one.
		BeanDefinitionParserDelegate parent = this.delegate;
		this.delegate = createDelegate(getReaderContext(), root, parent);

		if (this.delegate.isDefaultNamespace(root)) {
			String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
			if (StringUtils.hasText(profileSpec)) {
				String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
						profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
				// We cannot use Profiles.of(...) since profile expressions are not supported
				// in XML config. See SPR-12458 for details.
				if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
					if (logger.isDebugEnabled()) {
						logger.debug("Skipped XML bean definition file due to specified profiles [" + profileSpec +
								"] not matching: " + getReaderContext().getResource());
					}
					return;
				}
			}
		}
// 模板方法模式，提供给子类进行实现，默认是没有实现的，protected 方法
		preProcessXml(root);
		parseBeanDefinitions(root, this.delegate);
		postProcessXml(root);

		this.delegate = parent;
	}
```

- 观察者模式（spring 的事件监听机制使用的是这个模式）