> 被问到的一些知识点，后面完善一下

1. 标识符

2. 拆箱和包装

3. 线程的状态之间的转换

4. 构造器显示调用，static代码块执行顺序，初始化顺序等。

5. static关键字

6. 形参实参，包装类参数，基本类型参数

7. switch case的穿透（坑）

8. 线程的run()方法和没有使用start()方法的差别。

9. 方法传递参数（引用类型、基本类型），在方法里面修改参数的值，实参的变化

10. 单例模式的定义（手写）

11. spring mvc的原理

12. MySQL索引的结构、如何创建索引、创建索引遵循的原则

13. hashmap的原理，什么时候重写hashcode()和equals()方法

14. TCP/IP协议，三次握手，四次挥手、TCP和UDP的区别

15. hashmap为什么是8转成树结构，怎么转换的

16. try catch finally中return 代码返回位置不一样，返回什么结果

17. try catch finally 里面自定义异常代码块，catch的应该是哪个

18. 子类父类构造器初始化顺序

19. 网络协议七层模型（对应的有哪些协议）

20. Class a = new Class();Class b = new Class(); a==b?输出什么。为什么？Class对象考察

21. 数据库的基本语句

22. ArrayList和LinkedList区别

23. hashmap（不同步）和concurrentHashMap（同步）

24. 多线程，notify()和notifyAll()的区别，以及synchronized关键字

25. jsp的一些内置对象

26. 分布式

    dubbo、zookeeper、springcloud、springboot、
27. 线程
28. spring
事务：注解、声明式
29. sql优化

项目：
智搜（spring、SpringMVC、hibernate、hibernateJPA、dubbo、zookeeper、solr、es、netty、jetty、socket、单点登录
jQuery、js、java、servlet、线程、线程池、maven

### 新华面试的一些问题

##### Java

反射

##### 数据库

@Transaction 什么时候失效

两千万数据 B+ 树高度是多少？

聚簇索引

index 索引为啥查询很快

> B+ 树的查询效率，log n，相比全表扫描当然很快。



##### 多线程

##### JVM

什么时候发生 Minor GC？

> 当 eden 区满了的时候触发

[图解Tomcat类加载机制(阿里面试题) - aspirant - 博客园 (cnblogs.com)](https://www.cnblogs.com/aspirant/p/8991830.html) 

##### spring

静态代理和动态代理区别



#### Spring 可能面试题总结

###### 1 spring 中使用到的模式

- 工厂模式

- 建造者模式


```java 
// 加载 xml 文件，建造者模式+工厂模式使用。 org.springframework.beans.factory.xml.DefaultDocumentLoader#loadDocument 
public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,
                             ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {

    DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);
    if (logger.isTraceEnabled()) {
        logger.trace("Using JAXP provider [" + factory.getClass().getName() + "]");
    }
    DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
    return builder.parse(inputSource);
}
```

- 模板方法模式

```java 
//org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions, 这里的 root  是 <beans xxxx></beans>
protected void doRegisterBeanDefinitions(Element root) {
		// Any nested <beans> elements will cause recursion in this method. In
		// order to propagate and preserve <beans> default-* attributes correctly,
		// keep track of the current (parent) delegate, which may be null. Create
		// the new (child) delegate with a reference to the parent for fallback purposes,
		// then ultimately reset this.delegate back to its original (parent) reference.
		// this behavior emulates a stack of delegates without actually necessitating one.
		BeanDefinitionParserDelegate parent = this.delegate;
		this.delegate = createDelegate(getReaderContext(), root, parent);

		if (this.delegate.isDefaultNamespace(root)) {
			String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
			if (StringUtils.hasText(profileSpec)) {
				String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
						profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
				// We cannot use Profiles.of(...) since profile expressions are not supported
				// in XML config. See SPR-12458 for details.
				if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
					if (logger.isDebugEnabled()) {
						logger.debug("Skipped XML bean definition file due to specified profiles [" + profileSpec +
								"] not matching: " + getReaderContext().getResource());
					}
					return;
				}
			}
		}
// 模板方法模式，提供给子类进行实现，默认是没有实现的，protected 方法
		preProcessXml(root);
		parseBeanDefinitions(root, this.delegate);
		postProcessXml(root);

		this.delegate = parent;
	}
```

- 观察者模式（spring 的事件监听机制使用的是这个模式）