### 算法与数据结构

学习《漫画算法：小灰的算法之旅》

---

### 1 算法概述

#### 算法与数据结构  

##### 什么是算法？  

算法，对应的英文单词是algorithm，来自于数学领域。算法有简单的，也有复杂的；有高效的，也有拙劣的。  

**衡量算法好坏的重要标准有两个**。   

- **时间复杂度**
- **空间复杂度**

算法应用在多个领域。

1. 运算

   例如求出两个数的最大公约数，要做到效率的极致，的确需要动一番脑筋。再如计算两个超大整数的和，按照正常方式来计算肯定会导致变量溢出。这又该如何求解呢？  

2. 查找

   在数据中执行某一条SQL语句时，有思考过数据和信息时如何被查出来的呢？  

3. 排序

   排序算法是实现许多复杂程序的基石。  

4. 最优决策

   找到迷宫的最佳路线。  

---

##### 什么是数据结构？  

数据结构是算法的基石。对应的英文单词是 data structure，是数据的组织、管理和存储格式，其使用目的是为了高效地访问和修改数据。  

数据结构的组成方式。  

- **线性结构**  

线性结构是最简单的数据结构，包括数组、链表，以及由它们衍生出来的栈、队列、哈希表等。  

![image-20210528093041852](media/images/image-20210528093041852.png)

- **树**  

树是相对复杂的数据结构，其中比较有代表性的是二叉树，由它又衍生除了**二叉堆**之类的数据结构。  

![image-20210528093054390](media/images/image-20210528093054390.png)

- **图**

图是更为复杂的数据结构，因为在途中会呈现出多对多的关联关系。  

![image-20210528093153084](media/images/image-20210528093153084.png)

- **其他数据结构**  

除上述所列的几种基本数据结构以外，还有一些其他的千奇百怪的数据结构。它们由基本数据结构变形而来，用于解决某些特定问题，如 跳表、哈希链表、位图等。  

---

#### 时间复杂度  

一个例子

> 小灰和大黄同时加入了同一家公司，分别布置一个需求，用代码实现。在小灰和大黄各自交付了各自的代码，两人的代码实现功能差不多。  
>
> 大黄的代码运行一次要花100ms，占用内存5MB。 
>
> 小灰的代码运行一次要花100s，占用内存500MB。
>
> 于是……
>
> 小灰被让收拾东西走人...

虽然两人都实现了功能，但是小灰的代码存在两个很严重的问题。

1. **运行时间长**  
2. **占用空间大**  

由此可见，运行时间的长短和占用内存空间的大小，是衡量程序好坏的重要因素。  

**代码的绝对执行时间是无法预估的。但是我们却可以预估代码的基本执行次数**。  如以下场景：   

**场景1**：给小灰1个长度为10cm的面包，小灰每3分钟吃掉1cm，那么 吃掉整个面包需要多久？  

**答案**：3*10=30分钟  

如果面包的长度是n cm呢？此时吃掉整个面包，需要 3*n=3n 分钟。如果用一个函数来表达吃掉整个面包所需的时间，可以记作`T(n)=3n`，n为面包的长度。    

**场景2**：给小灰1个长度为16cm的面包，小灰每5分钟吃掉面包剩余长度的一半，即第5分钟吃掉8cm，第10分钟吃掉4cm，第15分钟吃掉 2cm……那么小灰把面包吃得只剩1cm，需要多久呢？   

**答案**：这个问题用数学方式表达就是，数字16不断地除以2，那么除几次以后的结果等于1？这里涉及数学中的对数，即以2为底16的对数 `log2 16`。（注：本书下文中对数函数的底数全部省略。）

因此，把面包吃得只剩下`1cm`，需要`5*log16=20`分钟。

如果面包的长度是n cm呢？此时需要 `5*log n`分钟，记作`T(n)=5logn`。 

**场景3**：给小灰1个长度为10cm的面包和1个鸡腿，小灰每2分钟吃 掉1个鸡腿。那么小灰吃掉整个鸡腿需要多久呢？

**答案**：2分钟。因为这里只要求吃掉鸡腿，和10cm的面包没有关系。无论面包多长，吃掉鸡腿的时间都是2分钟，记作`T(n)=2`。  

**场景4**：给小灰1个长度为10cm的面包，小灰吃掉第1个1cm需要1分钟时间，吃掉第2个1cm需要2分钟时间，吃掉第3个1cm需要3分钟时 间……每吃1cm所花的时间就比吃上一个1cm多用1分钟。那么小灰吃掉 整个面包需要多久呢？
**答案**：是从1累加到10的总和，也就是55分钟。 如果面包的长度是n cm呢？ 

根据高斯算法，此时吃掉整个面包需要` 1+2+3+…+(n-1)+ n `即 `(1+n)×n/2`分钟，也就是`0.5n^2 + 0.5n`分钟，记作`T(n) = 0.5n^2 + 0.5n`。

**设T(n)为程序基本操作执行次数的函数（也可以认为是程序的相对执行时间函数），n为输入规模**，刚才的4个场景分别对应了程序中最常见的4种执行方式。

场景1：`T(n)=3n`

```java
void eat1(int n) {
    System.out.println("等待1分钟");
    System.out.println("等待1分钟");
    System.out.println("吃1cm 面包");
}
```

场景2：`T(n)=5logn`

```java
void eat2(int n) {
    for(int i = n; i > 1; i = i/2){
    System.out.println("等待1分钟");
    System.out.println("等待1分钟");
    System.out.println("等待1分钟");
    System.out.println("等待1分钟");
    System.out.println("吃一半面包");
   }
}
```

场景3：`T(n)=2`

```java
void eat2(int n) {
    System.out.println("等待1分钟");
    System.out.println("吃一个鸡腿");
}
```

场景4：`T(n) = 0.5n^2 + 0.5n`

```java
void eat2(int n) {
    for(int i = 0; i < n; i++){
        for(int j = 0; j < i; i = j++){
             System.out.println("等待1分钟");
        }
        System.out.println("吃1cm面包");
    }
}
```

##### 渐进时间复杂度  

有了**基本操作执行次数的函数  T(n)**，是否就可以分析和比较代码的运行时间了呢？还是有一定困难的。

为了解决时间分析的难题，有了**渐进时间复杂度**（asymptotic time complexity）的概念，官方定义如下：

**若存在函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=O(f(n))，称为O(f(n))，O为算法的渐进时间复杂度，简称为时间复杂度。**也称作大O表示法。  

直白地讲，时间复杂度就是把程序的相对执行时间函数 T(n) 简化为一个数量级，整个数量级可以是n、n^2、n^3等。  

**如何推导出时间复杂度呢**？有如下几个原则。

- **如果运行时间是常数量级，则用常数1表示** 

- **只保留时间函数中的最高阶项** 

- **如果最高阶项存在，则省去最高阶项前面的系数**

再看上面四个场景。 

场景1：`T(n)=3n`，最高阶项为3n，省去系数3，则转化的时间复杂度为：`T(n)=O(n)`;

场景2：`T(n) = 5logn`，最高阶项为5logn，省去系数5，则转化的时间复杂度为：`T(n) =O(logn)`。

场景3：`T(n) = 2`，只有常数量级，则转化的是按复杂度为：`T(n) =O(1)`。  

场景4：`T(n) = 0.5n2+ 0.5n`，最高阶项为0.5n2，省去系数0.5，则转化的时间复杂度为：`T(n)
=O(n2)`。

当n的取值足够大时，有以下结论。

> O(1)<O(log n)<O(n)<O(n^2)



##### 时间复杂度的巨大差异  

有如下例子：

算法A的执行次数是T(n)= 100n，时间复杂度是O(n)。   

算法B的执行次数是T(n)= 5n^2，时间复杂度是O(n^2)。  

算法A运行在小灰家里的老旧电脑上，算法B运行在某台超级计算机上，超级计算机的运行速度是老旧电脑的100倍。随着输入规模的增长，两种算法谁运行速度更快呢？  

![image-20210528112324814](media/images/image-20210528112324814.png)

从上面的表格可以看出，当n的值很小时，算法A的运行用时要远大于算法B；当n的值在1000左右时，算法A和算法B的运行时间已经比 较接近；随着n的值越来越大，甚至达到十万、百万时，算法A的优势 开始显现出来，算法B的运行速度则越来越慢，差距越来越明显。   

---

#### 空间复杂度   

**简单来说，时间复杂度时执行算法时间的时间成本，空间复杂度时执行算法的空间成本**。在运行一段程序时，我们不仅要执行各种运算指令，同时也会根据需要，存储一些临时的中间数据，以便后续的指令可以更方便地执行。  

  如以下例子：

```java
3 1 2 5 4 9 7 2
```

**找出这些数字中两个重复的整数**。  最朴素的方法就是双重循环。遍历整个数列，每遍历到一个新的整数就开始回顾之前遍历过的所有整数，再看看这些整数里有没有与之数值相同的。  

第1步，遍历整数3，前面没有数字，所以无须回顾比较。 

第2步，遍历整数1，回顾前面的数字3，没有发现重复数字。 

第3步，遍历整数2，回顾前面的数字3、1，没有发现重复数字。

....  

后续步骤类似，一直遍历到最后的整数2，发现和前面的整数2重复.   

基本的执行次数为 T(n) = n * n ，O(f(n)) = n^2，这个算法的时间复杂度为：O(n^2)。  

如何提高这个算法的效率呢？当遍历整个数列的时候，每遍历一个整数，就把该整数存储起来，就像放到字典中一样。当遍历下一个整数时，不必再慢慢向前回溯比较，而直接去“字典”中查找，看看有没有对应的整数即可。  

![image-20210528114222917](media/images/image-20210528114222917.png)

由于读写“字典”本身的时间复杂度是O(1)，所以整个算法的时间复杂度是O(n)，和最初的双重循环相比，运行效率大大提高了。**而这个所谓的“字典”，是一种特殊的数据结构，叫作散列表**。这个数据结构需要开辟一定的内存空间来存储有用的数据信息。

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，它同样使用大O表示法。计算公式记作`S(n)=O(f(n))`,其中n为问题的规模，f(n)为算法所占存储空间的函数.

**空间复杂度计算**   

1. **常量空间**

   当算法的存储空间大小固定，和输入规模没有直接的关系时，空间复杂度记作O(1),例如：

   ```java
   void fun1(int n) {
       int a = 3;
       ....
   }
   ```

2. **线性空间**  

   当算法分配的空间是一个线性的集合（如数组），并且集合大小和输入规模n成正比时，空间复杂度记作O(n)。

   ```java
   void fun2(int n) {
       int[] array = new int[n];
   }
   ```

3. **二维空间**  

   当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都 与输入规模n成正比时，空间复杂度记作O(n2)。

   ```java
   void fun3(int n) {
       int[][] matrix = new int[n][n];
   }
   ```

4. **递归空间**

   **执行递归操作所需要的内存空间和递归的深度成正比**。纯粹的递归操作的空间复杂度也是线性的，如果递归的深度是n，那么空间复杂度就是O(n)。  

   ```java
   void fun4(int n) {
       if(n < 1) {
           return;
       }
       fun4(n-1);
   }
   ```

#### 时间与空间的取舍 

在寻找重复整数的例子中，双重循环的时间复杂度是O(n^2)，空间复杂度是O(1)，这属于牺牲时间来换取空间的情况。 

相反，字典法的空间复杂度是O(n)，时间复杂度是O(n)，这属于牺牲空间来换取时间的情况。

### 2 数据结构基础  

#### 数组（顺序存储）  

数组对应的英文是array，是有限个相同类型的变量所组成的有序集合，数组中的每一个变量被称为元素。数组是最为简单、最为常用的数据结构。

![image-20210528122405993](media/images/image-20210528122405993.png)

- 数组的下标从0开始，一直到数组长度-1 
- 数组在内存中顺序存储，因此可以很好地实现逻辑上的顺序表

**内存是由一个个连续的内存单元组成的，每一个内存单元都有自己的地址。在这些内存单元中，有些被其他数据占用了，有些是空闲的**。  

数组中的每一个元素，都存储在小小的内存单元中，并且元素之间紧密排列，既不能打乱元素的存储顺序，也不能跳过某个存储单元进行存储。

![image-20210528122523508](media/images/image-20210528122523508.png)

橙色格子代表空闲的存储单元，灰色的格子代表已占用的存储单元，而红色的连续的则是数组在内存中的位置。  

##### 数组基本操作 

**读取元素和更新元素的时间复杂度都是O(1).**

插入元素：

- 尾部插入
- 中间插入
- 超范围插入

中间插入数据的时候，要将插入位置及后面的元素向后移动，腾出地方，再把要插入的元素放到对应的数组位置上。 

插入的时候要注意是不是超过了数组的大小，超过大小的话，则要进行扩容处理，将数组扩容为原来的2倍。

```java
int arrayNew = new int[array.length * 2];
/*
*    * @param      src      the source array.
     * @param      srcPos   starting position in the source array.
     * @param      dest     the destination array.
     * @param      destPos  starting position in the destination data.
     * @param      length   the number of array elements to be copied.
     public static native void arraycopy(Object src,  int  srcPos,
                                        Object dest, int destPos,
                                        int length);
*/
// 从旧数组复制到新数组
System.arraycopy(array, 0, arrayNew, 0, array.length);
array = arrayNew;
```

删除元素：删除元素和插入操作的过程相反，如果删除的元素位于数组的中间，其后的元素都需要向前挪动1位。

数组扩容的时间复杂度是O(n)，插入并移动元素的时间复杂度也是O(n)，综合起来操作的时间复杂度是O(n)。删除操作，只涉及到元素的移动，时间复杂度也是O(n)。

**删除的小技巧：**

小技巧的前提是：数组元素没有顺序的要求。  

![image-20210528170829392](media/images/image-20210528170829392.png)

##### 数组的优势和劣势  

优势：

- 高效的随机访问能力

劣势：

- 插入和删除元素，会导致大量元素被迫移动，影响效率。

总的来说，数组适合的是**读操作多、写操作少**的场景。  

#### 链表  

链表（Linked List）是一种在物理上非连续、非顺序的数据结构，由若干个（node）所组成。  

##### 单向链表  

单向链表的结构

![image-20210528172127544](media/images/image-20210528172127544.png)

单向链表的每一个节点又包含两个部分，一部分是存放数据的变量 data，另一部分是指向下一个节点的指针 next。  

```java
private static class Node {
	int data;
    Node next;
}
```

**链表的第1个节点被称为头节点，最后一个节点被称为尾节点，尾节点的next指针指向空。**  

与数组按照下标来随机寻找元素不同，对于链表的其中一个节点A，我们只能根据节点A的next指针来找到该节点的下一个节点B，再根据节点B的next指针找到下一个节点C。。。层层递进。  

如何找到前一个节点呢？这个时候使用“双向链表”。  

##### 双向链表   

双向链表的结构

![image-20210528172749519](media/images/image-20210528172749519.png)

双向链表的每一个节点还拥有前置节点的prev指针。

```java
private static class Node {
	int data;
    Node next;
}
```

##### 链表的存储方式 (随机存储) 

而链表则采用了见缝插针的方式，链表的每一个节点 分布在内存的不同位置，依靠next指针关联起来。这样可以灵活有效地 利用零散的碎片空间。如图：

![image-20210528172952155](media/images/image-20210528172952155.png)

##### 链表的基本操作  

- **查找节点**

链表只能从头节点开始向后一个一个节点逐一查找。例如，给出一个链表，需要查找从头节点开始的第3个节点。

1. 将查找的指针定位到头节点
2. 根据指针的头节点的next指针，定位到第2个节点
3. 根据第2个节点的next指针，定位到第3个节点，查找完毕

**查找链表节点的时间复杂度为：O(n)**； 

- **更新节点**

直接把旧数据替换成新数据即可。

- **插入节点**
  - 尾部插入
  - 头部插入
  - 中间插入

**尾部插入**：是最简单的情况，把最后一个节点的next指针指向新插入的节点即可，新插入的节点的next指针为空。  

![image-20210528173943935](media/images/image-20210528173943935.png)

**头部插入**：（1）把新节点的next指针指向原先的头节点。（2）把新节点变为链表的头节点。  

![image-20210528174101775](media/images/image-20210528174101775.png)

**中间插入**：（1）新节点的next指针，指向插入位置的节点。（2）插入位置前置节点的next指针，指向新节点。  

![image-20210528174355446](media/images/image-20210528174355446.png)

- 删除元素

**尾部删除**：最简单的情况，把倒数第2个节点的next指针指向空即可。  

![image-20210531213729058](media/images/image-20210531213729058.png)

**头部删除**：也很简单，把链表的头节点设为原先节点的next指针。  

![image-20210531213832550](media/images/image-20210531213832550.png)

**中间删除**：把要删除的节点的前置节点的next指针，指向要删除元素的下一个节点即可。   

![image-20210531213922143](media/images/image-20210531213922143.png)

插入和删除操作的时间复杂度都是O(1)，不考虑查找节点的操作的前提下。

```java
/**
 * @program: dataStructure->MyLinkedList
 * @description: 链表的操作
 * @author: lanwenquan
 * @date: 2021-05-31 21:41
 */
public class MyLinkedList {

    /**
     * 头节点
     */
    private Node head;
    private Node last;
    private int size;

    /**
     * 插入节点
     */
    public void insertNode(int data, int index) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException("超出链表节点范围！！！");
        }
        Node insertNode = new Node(data);
        if (size == 0) {
            // 空链表
            head = insertNode;
            last = insertNode;
        } else if (index == 0) {
            // 头插法
            insertNode.next = head;
            head = insertNode;
        } else if (index == size) {
            // 尾插法
            last.next = insertNode;
            last = insertNode;
        } else {
            // 中间插入
            Node prevNode = getNode(index);
            insertNode.next = prevNode.next;
            prevNode.next = insertNode;
        }
        size++;
    }

    /**
     * 查找节点
     */
    public Node getNode(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("超出链表节点范围！！！");
        }
        Node temp = head;
        for (int i = 0; i < index; i++) {
            temp = temp.next;
        }
        return temp;
    }

    /**
     * 删除节点
     */
    public Node remove(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("超出链表节点范围！！！");
        }
        Node removeNode = null;
        if (index == 0) {
            // 删除头节点
            head = head.next;
            removeNode = head;
        } else if (index == size - 1) {
            // 删除尾节点
            Node prevNode = getNode(index - 1);
            removeNode = prevNode.next;
            prevNode.next = null;
            last = prevNode;
        } else {
            // 删除中间节点
            Node prevNode = getNode(index - 1);
            Node nextNode = prevNode.next;
            removeNode = prevNode.next;
            prevNode.next = nextNode.next;
        }
        size--;
        return removeNode;
    }

    public void output() {
        Node temp = head;
        while (temp != null) {
            System.out.println(temp.data);
            temp = temp.next;
        }
    }

    /**
     * 节点
     */
    public static class Node {
        // 下一个节点
        private Node next;
        // 数据
        int data;

        public Node(int data) {
            this.data = data;
        }
    }

    public static void main(String[] args) {
        MyLinkedList myLinkedList = new MyLinkedList();
        myLinkedList.insertNode(3, 0);
        myLinkedList.insertNode(7, 1);
        myLinkedList.insertNode(9, 2);
        myLinkedList.insertNode(5, 3);
        myLinkedList.insertNode(6, 4);
        myLinkedList.insertNode(8, 5);
        myLinkedList.remove(2);
        myLinkedList.output();
    }
}
```

**数组和链表的性能对比**：

![image-20210531224953995](media/images/image-20210531224953995.png)



#### 栈和队列  

#### 散列表  



