### 算法与数据结构

学习《漫画算法：小灰的算法之旅》

---

### 1 算法概述

#### 算法与数据结构  

##### 什么是算法？  

算法，对应的英文单词是algorithm，来自于数学领域。算法有简单的，也有复杂的；有高效的，也有拙劣的。  

**衡量算法好坏的重要标准有两个**。   

- **时间复杂度**
- **空间复杂度**

算法应用在多个领域。

1. 运算

   例如求出两个数的最大公约数，要做到效率的极致，的确需要动一番脑筋。再如计算两个超大整数的和，按照正常方式来计算肯定会导致变量溢出。这又该如何求解呢？  

2. 查找

   在数据中执行某一条SQL语句时，有思考过数据和信息时如何被查出来的呢？  

3. 排序

   排序算法是实现许多复杂程序的基石。  

4. 最优决策

   找到迷宫的最佳路线。  

---

##### 什么是数据结构？  

数据结构是算法的基石。对应的英文单词是 data structure，是数据的组织、管理和存储格式，其使用目的是为了高效地访问和修改数据。  

数据结构的组成方式。  

- **线性结构**  

线性结构是最简单的数据结构，包括数组、链表，以及由它们衍生出来的栈、队列、哈希表等。  

![image-20210528093041852](media/images/image-20210528093041852.png)

- **树**  

树是相对复杂的数据结构，其中比较有代表性的是二叉树，由它又衍生除了**二叉堆**之类的数据结构。  

![image-20210528093054390](media/images/image-20210528093054390.png)

- **图**

图是更为复杂的数据结构，因为在途中会呈现出多对多的关联关系。  

![image-20210528093153084](media/images/image-20210528093153084.png)

- **其他数据结构**  

除上述所列的几种基本数据结构以外，还有一些其他的千奇百怪的数据结构。它们由基本数据结构变形而来，用于解决某些特定问题，如 跳表、哈希链表、位图等。  

---

#### 时间复杂度  

一个例子

> 小灰和大黄同时加入了同一家公司，分别布置一个需求，用代码实现。在小灰和大黄各自交付了各自的代码，两人的代码实现功能差不多。  
>
> 大黄的代码运行一次要花100ms，占用内存5MB。 
>
> 小灰的代码运行一次要花100s，占用内存500MB。
>
> 于是……
>
> 小灰被让收拾东西走人...

虽然两人都实现了功能，但是小灰的代码存在两个很严重的问题。

1. **运行时间长**  
2. **占用空间大**  

由此可见，运行时间的长短和占用内存空间的大小，是衡量程序好坏的重要因素。  

**代码的绝对执行时间是无法预估的。但是我们却可以预估代码的基本执行次数**。  如以下场景：   

**场景1**：给小灰1个长度为10cm的面包，小灰每3分钟吃掉1cm，那么 吃掉整个面包需要多久？  

**答案**：3*10=30分钟  

如果面包的长度是n cm呢？此时吃掉整个面包，需要 3*n=3n 分钟。如果用一个函数来表达吃掉整个面包所需的时间，可以记作`T(n)=3n`，n为面包的长度。    

**场景2**：给小灰1个长度为16cm的面包，小灰每5分钟吃掉面包剩余长度的一半，即第5分钟吃掉8cm，第10分钟吃掉4cm，第15分钟吃掉 2cm……那么小灰把面包吃得只剩1cm，需要多久呢？   

**答案**：这个问题用数学方式表达就是，数字16不断地除以2，那么除几次以后的结果等于1？这里涉及数学中的对数，即以2为底16的对数 `log2 16`。（注：本书下文中对数函数的底数全部省略。）

因此，把面包吃得只剩下`1cm`，需要`5*log16=20`分钟。

如果面包的长度是n cm呢？此时需要 `5*log n`分钟，记作`T(n)=5logn`。 

**场景3**：给小灰1个长度为10cm的面包和1个鸡腿，小灰每2分钟吃 掉1个鸡腿。那么小灰吃掉整个鸡腿需要多久呢？

**答案**：2分钟。因为这里只要求吃掉鸡腿，和10cm的面包没有关系。无论面包多长，吃掉鸡腿的时间都是2分钟，记作`T(n)=2`。  

**场景4**：给小灰1个长度为10cm的面包，小灰吃掉第1个1cm需要1分钟时间，吃掉第2个1cm需要2分钟时间，吃掉第3个1cm需要3分钟时 间……每吃1cm所花的时间就比吃上一个1cm多用1分钟。那么小灰吃掉 整个面包需要多久呢？
**答案**：是从1累加到10的总和，也就是55分钟。 如果面包的长度是n cm呢？ 

根据高斯算法，此时吃掉整个面包需要` 1+2+3+…+(n-1)+ n `即 `(1+n)×n/2`分钟，也就是`0.5n^2 + 0.5n`分钟，记作`T(n) = 0.5n^2 + 0.5n`。

**设T(n)为程序基本操作执行次数的函数（也可以认为是程序的相对执行时间函数），n为输入规模**，刚才的4个场景分别对应了程序中最常见的4种执行方式。

场景1：`T(n)=3n`

```java
void eat1(int n) {
    System.out.println("等待1分钟");
    System.out.println("等待1分钟");
    System.out.println("吃1cm 面包");
}
```

场景2：`T(n)=5logn`

```java
void eat2(int n) {
    for(int i = n; i > 1; i = i/2){
    System.out.println("等待1分钟");
    System.out.println("等待1分钟");
    System.out.println("等待1分钟");
    System.out.println("等待1分钟");
    System.out.println("吃一半面包");
   }
}
```

场景3：`T(n)=2`

```java
void eat2(int n) {
    System.out.println("等待1分钟");
    System.out.println("吃一个鸡腿");
}
```

场景4：`T(n) = 0.5n^2 + 0.5n`

```java
void eat2(int n) {
    for(int i = 0; i < n; i++){
        for(int j = 0; j < i; i = j++){
             System.out.println("等待1分钟");
        }
        System.out.println("吃1cm面包");
    }
}
```

##### 渐进时间复杂度  

有了**基本操作执行次数的函数  T(n)**，是否就可以分析和比较代码的运行时间了呢？还是有一定困难的。

为了解决时间分析的难题，有了**渐进时间复杂度**（asymptotic time complexity）的概念，官方定义如下：

**若存在函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=O(f(n))，称为O(f(n))，O为算法的渐进时间复杂度，简称为时间复杂度。**也称作大O表示法。  

直白地讲，时间复杂度就是把程序的相对执行时间函数 T(n) 简化为一个数量级，整个数量级可以是n、n^2、n^3等。  

**如何推导出时间复杂度呢**？有如下几个原则。

- **如果运行时间是常数量级，则用常数1表示** 

- **只保留时间函数中的最高阶项** 

- **如果最高阶项存在，则省去最高阶项前面的系数**

再看上面四个场景。 

场景1：`T(n)=3n`，最高阶项为3n，省去系数3，则转化的时间复杂度为：`T(n)=O(n)`;

场景2：`T(n) = 5logn`，最高阶项为5logn，省去系数5，则转化的时间复杂度为：`T(n) =O(logn)`。

场景3：`T(n) = 2`，只有常数量级，则转化的是按复杂度为：`T(n) =O(1)`。  

场景4：`T(n) = 0.5n2+ 0.5n`，最高阶项为0.5n2，省去系数0.5，则转化的时间复杂度为：`T(n)
=O(n2)`。

当n的取值足够大时，有以下结论。

> O(1)<O(log n)<O(n)<O(n^2)



##### 时间复杂度的巨大差异  

有如下例子：

算法A的执行次数是T(n)= 100n，时间复杂度是O(n)。   

算法B的执行次数是T(n)= 5n^2，时间复杂度是O(n^2)。  

算法A运行在小灰家里的老旧电脑上，算法B运行在某台超级计算机上，超级计算机的运行速度是老旧电脑的100倍。随着输入规模的增长，两种算法谁运行速度更快呢？  

![image-20210528112324814](media/images/image-20210528112324814.png)

从上面的表格可以看出，当n的值很小时，算法A的运行用时要远大于算法B；当n的值在1000左右时，算法A和算法B的运行时间已经比 较接近；随着n的值越来越大，甚至达到十万、百万时，算法A的优势 开始显现出来，算法B的运行速度则越来越慢，差距越来越明显。   

---

#### 空间复杂度   

**简单来说，时间复杂度时执行算法时间的时间成本，空间复杂度时执行算法的空间成本**。在运行一段程序时，我们不仅要执行各种运算指令，同时也会根据需要，存储一些临时的中间数据，以便后续的指令可以更方便地执行。  

  如以下例子：

```java
3 1 2 5 4 9 7 2
```

**找出这些数字中两个重复的整数**。  最朴素的方法就是双重循环。遍历整个数列，每遍历到一个新的整数就开始回顾之前遍历过的所有整数，再看看这些整数里有没有与之数值相同的。  

第1步，遍历整数3，前面没有数字，所以无须回顾比较。 

第2步，遍历整数1，回顾前面的数字3，没有发现重复数字。 

第3步，遍历整数2，回顾前面的数字3、1，没有发现重复数字。

....  

后续步骤类似，一直遍历到最后的整数2，发现和前面的整数2重复.   

基本的执行次数为 T(n) = n * n ，O(f(n)) = n^2，这个算法的时间复杂度为：O(n^2)。  

如何提高这个算法的效率呢？当遍历整个数列的时候，每遍历一个整数，就把该整数存储起来，就像放到字典中一样。当遍历下一个整数时，不必再慢慢向前回溯比较，而直接去“字典”中查找，看看有没有对应的整数即可。  

![image-20210528114222917](media/images/image-20210528114222917.png)

由于读写“字典”本身的时间复杂度是O(1)，所以整个算法的时间复杂度是O(n)，和最初的双重循环相比，运行效率大大提高了。**而这个所谓的“字典”，是一种特殊的数据结构，叫作散列表**。这个数据结构需要开辟一定的内存空间来存储有用的数据信息。

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，它同样使用大O表示法。计算公式记作`S(n)=O(f(n))`,其中n为问题的规模，f(n)为算法所占存储空间的函数.

**空间复杂度计算**   

1. **常量空间**

   当算法的存储空间大小固定，和输入规模没有直接的关系时，空间复杂度记作O(1),例如：

   ```java
   void fun1(int n) {
       int a = 3;
       ....
   }
   ```

2. **线性空间**  

   当算法分配的空间是一个线性的集合（如数组），并且集合大小和输入规模n成正比时，空间复杂度记作O(n)。

   ```java
   void fun2(int n) {
       int[] array = new int[n];
   }
   ```

3. **二维空间**  

   当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都 与输入规模n成正比时，空间复杂度记作O(n2)。

   ```java
   void fun3(int n) {
       int[][] matrix = new int[n][n];
   }
   ```

4. **递归空间**

   **执行递归操作所需要的内存空间和递归的深度成正比**。纯粹的递归操作的空间复杂度也是线性的，如果递归的深度是n，那么空间复杂度就是O(n)。  

   ```java
   void fun4(int n) {
       if(n < 1) {
           return;
       }
       fun4(n-1);
   }
   ```

#### 时间与空间的取舍 

在寻找重复整数的例子中，双重循环的时间复杂度是O(n^2)，空间复杂度是O(1)，这属于牺牲时间来换取空间的情况。 

相反，字典法的空间复杂度是O(n)，时间复杂度是O(n)，这属于牺牲空间来换取时间的情况。

### 2 数据结构基础  

#### 数组（顺序存储）  

数组对应的英文是array，是有限个相同类型的变量所组成的有序集合，数组中的每一个变量被称为元素。数组是最为简单、最为常用的数据结构。

![image-20210528122405993](media/images/image-20210528122405993.png)

- 数组的下标从0开始，一直到数组长度-1 
- 数组在内存中顺序存储，因此可以很好地实现逻辑上的顺序表

**内存是由一个个连续的内存单元组成的，每一个内存单元都有自己的地址。在这些内存单元中，有些被其他数据占用了，有些是空闲的**。  

数组中的每一个元素，都存储在小小的内存单元中，并且元素之间紧密排列，既不能打乱元素的存储顺序，也不能跳过某个存储单元进行存储。

![image-20210528122523508](media/images/image-20210528122523508.png)

橙色格子代表空闲的存储单元，灰色的格子代表已占用的存储单元，而红色的连续的则是数组在内存中的位置。  

##### 数组基本操作 

**读取元素和更新元素的时间复杂度都是O(1).**

插入元素：

- 尾部插入
- 中间插入
- 超范围插入

中间插入数据的时候，要将插入位置及后面的元素向后移动，腾出地方，再把要插入的元素放到对应的数组位置上。 



##### 扩容

插入的时候要注意是不是超过了数组的大小，超过大小的话，则要进行扩容处理，将数组扩容为原来的2倍。

```java
int arrayNew = new int[array.length * 2];
/*
*    * @param      src      the source array.
     * @param      srcPos   starting position in the source array.
     * @param      dest     the destination array.
     * @param      destPos  starting position in the destination data.
     * @param      length   the number of array elements to be copied.
     public static native void arraycopy(Object src,  int  srcPos,
                                        Object dest, int destPos,
                                        int length);
*/
// 从旧数组复制到新数组
System.arraycopy(array, 0, arrayNew, 0, array.length);
array = arrayNew;
```

删除元素：删除元素和插入操作的过程相反，如果删除的元素位于数组的中间，其后的元素都需要向前挪动1位。

数组扩容的时间复杂度是O(n)，插入并移动元素的时间复杂度也是O(n)，综合起来操作的时间复杂度是O(n)。删除操作，只涉及到元素的移动，时间复杂度也是O(n)。

**删除的小技巧：**

小技巧的前提是：数组元素没有顺序的要求。  

![image-20210528170829392](media/images/image-20210528170829392.png)

##### 数组的优势和劣势  

优势：

- 高效的随机访问能力

劣势：

- 插入和删除元素，会导致大量元素被迫移动，影响效率。

总的来说，数组适合的是**读操作多、写操作少**的场景。  

#### 链表  

链表（Linked List）是一种在物理上非连续、非顺序的数据结构，由若干个（node）所组成。  

##### 单向链表  

单向链表的结构

![image-20210528172127544](media/images/image-20210528172127544.png)

单向链表的每一个节点又包含两个部分，一部分是存放数据的变量 data，另一部分是指向下一个节点的指针 next。  

```java
private static class Node {
	int data;
    Node next;
}
```

**链表的第1个节点被称为头节点，最后一个节点被称为尾节点，尾节点的next指针指向空。**  

与数组按照下标来随机寻找元素不同，对于链表的其中一个节点A，我们只能根据节点A的next指针来找到该节点的下一个节点B，再根据节点B的next指针找到下一个节点C。。。层层递进。  

如何找到前一个节点呢？这个时候使用“双向链表”。  

##### 双向链表   

双向链表的结构

![image-20210528172749519](media/images/image-20210528172749519.png)

双向链表的每一个节点还拥有前置节点的prev指针。

```java
private static class Node {
	int data;
    Node next;
}
```

##### 链表的存储方式 (随机存储) 

而链表则采用了见缝插针的方式，链表的每一个节点 分布在内存的不同位置，依靠next指针关联起来。这样可以灵活有效地 利用零散的碎片空间。如图：

![image-20210528172952155](media/images/image-20210528172952155.png)

##### 链表的基本操作  

- **查找节点**

链表只能从头节点开始向后一个一个节点逐一查找。例如，给出一个链表，需要查找从头节点开始的第3个节点。

1. 将查找的指针定位到头节点
2. 根据指针的头节点的next指针，定位到第2个节点
3. 根据第2个节点的next指针，定位到第3个节点，查找完毕

**查找链表节点的时间复杂度为：O(n)**； 

- **更新节点**

直接把旧数据替换成新数据即可。

- **插入节点**
  - 尾部插入
  - 头部插入
  - 中间插入

**尾部插入**：是最简单的情况，把最后一个节点的next指针指向新插入的节点即可，新插入的节点的next指针为空。  

![image-20210528173943935](media/images/image-20210528173943935.png)

**头部插入**：（1）把新节点的next指针指向原先的头节点。（2）把新节点变为链表的头节点。  

![image-20210528174101775](media/images/image-20210528174101775.png)

**中间插入**：（1）新节点的next指针，指向插入位置的节点。（2）插入位置前置节点的next指针，指向新节点。  

![image-20210528174355446](media/images/image-20210528174355446.png)

- 删除元素

**尾部删除**：最简单的情况，把倒数第2个节点的next指针指向空即可。  

![image-20210531213729058](media/images/image-20210531213729058.png)

**头部删除**：也很简单，把链表的头节点设为原先节点的next指针。  

![image-20210531213832550](media/images/image-20210531213832550.png)

**中间删除**：把要删除的节点的前置节点的next指针，指向要删除元素的下一个节点即可。   

![image-20210531213922143](media/images/image-20210531213922143.png)

插入和删除操作的时间复杂度都是O(1)，不考虑查找节点的操作的前提下。

```java
/**
 * @program: dataStructure->MyLinkedList
 * @description: 链表的操作
 * @author: lanwenquan
 * @date: 2021-05-31 21:41
 */
public class MyLinkedList {

    /**
     * 头节点
     */
    private Node head;
    private Node last;
    private int size;

    /**
     * 插入节点
     */
    public void insertNode(int data, int index) {
        if (index < 0 || index > size) {
            throw new IndexOutOfBoundsException("超出链表节点范围！！！");
        }
        Node insertNode = new Node(data);
        if (size == 0) {
            // 空链表
            head = insertNode;
            last = insertNode;
        } else if (index == 0) {
            // 头插法
            insertNode.next = head;
            head = insertNode;
        } else if (index == size) {
            // 尾插法
            last.next = insertNode;
            last = insertNode;
        } else {
            // 中间插入
            Node prevNode = getNode(index);
            insertNode.next = prevNode.next;
            prevNode.next = insertNode;
        }
        size++;
    }

    /**
     * 查找节点
     */
    public Node getNode(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("超出链表节点范围！！！");
        }
        Node temp = head;
        for (int i = 0; i < index; i++) {
            temp = temp.next;
        }
        return temp;
    }

    /**
     * 删除节点
     */
    public Node remove(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("超出链表节点范围！！！");
        }
        Node removeNode = null;
        if (index == 0) {
            // 删除头节点
            head = head.next;
            removeNode = head;
        } else if (index == size - 1) {
            // 删除尾节点
            Node prevNode = getNode(index - 1);
            removeNode = prevNode.next;
            prevNode.next = null;
            last = prevNode;
        } else {
            // 删除中间节点
            Node prevNode = getNode(index - 1);
            Node nextNode = prevNode.next;
            removeNode = prevNode.next;
            prevNode.next = nextNode.next;
        }
        size--;
        return removeNode;
    }

    public void output() {
        Node temp = head;
        while (temp != null) {
            System.out.println(temp.data);
            temp = temp.next;
        }
    }

    /**
     * 节点
     */
    public static class Node {
        // 下一个节点
        private Node next;
        // 数据
        int data;

        public Node(int data) {
            this.data = data;
        }
    }

    public static void main(String[] args) {
        MyLinkedList myLinkedList = new MyLinkedList();
        myLinkedList.insertNode(3, 0);
        myLinkedList.insertNode(7, 1);
        myLinkedList.insertNode(9, 2);
        myLinkedList.insertNode(5, 3);
        myLinkedList.insertNode(6, 4);
        myLinkedList.insertNode(8, 5);
        myLinkedList.remove(2);
        myLinkedList.output();
    }
}
```

**数组和链表的性能对比**：

![image-20210531224953995](media/images/image-20210531224953995.png)



#### 栈和队列  

#### 散列表  

散列表也叫做哈希表（hash table），这种数据结构提供了键（key）和值（value）的映射关系。只要给出一个key，就可以高效查找到它锁匹配的value，时间复杂度接近于O(1)。  

![image-20210607205411964](media/images/image-20210607205411964.png)

那么key是如何找到对应的value值的呢？这就要介绍散列表的基本原理了。  

##### 哈希函数    

散列表在本质上也是一个数组。可是数组只能根据下表，像a[0]、a[1]、a[2]等这样进行访问，而散列表的key则是以字符串类型为主的。要实现存储字符串等类型，我们需要一个“中转站”，**通过某种方式，把key和数组下表进行转换**。 这个中转站就叫做哈希函数。（转换成类似于数组的下标）   

![image-20210607205919018](media/images/image-20210607205919018.png)

如上图，存入“key3”通过哈希函数的转换，存入的位置是 2 这个位置，value则不用转换。然后获取 key3的时候再通过哈希函数转换去获取位置2的value值。  

但是这个哈希函数是怎么实现的呢？不同的语言中，哈希函数的实现方式是不一样的。Java中的实现如下：  

  Java中，每一个对象都有属于自己的hashcode值，这个hashcode是区分不同对象的重要标识。无论对象自身的类型是什么，他们的hashcode都是一个整型变量。既然是整型变量，想要转换成数组的下标便不是很难实现了。最简单的转化方式是什么呢？**是按照数组长度进行取模运算（转换成下标）**。  

> index = HashCode(Key) % Array.length

但是Java中的哈希函数并没有采用取模的运算，而是利用了位运算的方式来优化性能。  

通过哈希函数，我们可以把字符串或其他类型的Key，转化成数组的下标 index，然后进行操作。例如，当数组的长度为8时：

```java
当key ="001121"时
 index = HashCode("001121") % Array.length = 1420036703 % 8 = 7；
而当key = "this" 时
 index = HashCode("this") % Array.length = 3559070 % 8 = 6；
```

---

##### 散列表的读写操作   

- **写操作**

put(key, value) 插入新的键值对。如hashMap.put("002931", "王五")，操作步骤如下：

1，根据哈希函数，计算出002931对应的下标。2，如果数组下标的位置没有元素，就把这个entry填充到下标为5的位置。  

但是，数组的长度是有限的，当插入的 Entry 越来越多时，不同的 key 通过哈希函数计算出的下标值有可能是相同的。例如“002936”这个key对应的下标是2，“002947”这个key对应的下标也是2，这种情况就叫做哈希冲突。  

![image-20210607211343246](media/images/image-20210607211343246.png)

哈希冲突是无法避免的。解决哈希冲突的方法主要有两种，一种是**链表法**，另一种是**开放寻址法**。

- 开放寻址法 

当一个key通过哈希函数获得对应的数组下标已经被占用时，寻找下一个空档位置。  

例如：当上面的entry6通过哈希函数获得下标为2，但是下标2已经被占用了，那么向后移动一位，发现下标3也被占用了，再向后移动1位，下标4没有被占用，就可以放到这个位置了。（这是简单的举例，通过向后移动一位来找空的地址）。  ThreadLocal使用的就是开放寻址法。  

- 链表法 

当 entry6已经有，但是新的key计算出的下标也是2时，hashmap数组的每一个元素不仅是一个Entry对象，还是一个链表的头结点。冲突时，将冲突的 Entry 插入到entry6的链表中。（**实际上是一个节点数组 `Node<k,v>[] table`**）  

![image-20210607212017404](media/images/image-20210607212017404.png)

- **读操作**  

get(key)。  例如hashMap.get("002936")，意思是查找Key为002936的Entry在散列表中所对应的值，链表法的步骤如下：  

1，通过哈希函数，将key转换成数组下标2。2，找到数组下标2对应的元素，如果这个key是“002936”，那么就找到了；如果这个key不是“002936”，由于数组的每个元素都与一个链表对应，可以顺着链表慢慢往下找，看看能否找到与key相匹配的节点。  

![image-20210607212904080](media/images/image-20210607212904080.png)

在上图中，首先查到的节点Entry6的Key是002947，和待查找的Key002936不符。接着定位到链表下一个节点Entry1，发现Entry1的Key 002936正是我们要寻找的，所以返回Entry1的Value即可。

### 3 树和二叉树    

定义：树（Tree）是n（n>=）个节点的有限集。当n=0时，称为空树。在任意一个非空树，有如下特点。  

**1：有且仅有一个特定的称为跟的节点。**

**2：当n>1时，其余节点可分为m（m>0）个互不相交的有限集，每一个集合本身又是一个树，并称为跟的子树。**  

如下图，一个标准的树结构。根节点，叶子节点（没有孩子）。  

![image-20210614143935888](media/images/image-20210614143935888.png)

节点4的上一级节点2，是节点4的父节点；从节点4衍生出来的节点，是节点4的孩子结点；和节点4同级，由同一个父节点衍生出来的节点，是节点4的兄弟节点。树的最大层数，被称为树的高度或深度。上面这个树的高度是4。  

#### 什么是二叉树？   

二叉树（binary tree）是树的一种特殊形式。二叉树，这种树的每个节点最多有2个孩子节点。注意，这里是最多有2个，也有可能只有一个 ，或者没有孩子节点。  

结构如下图所示：  

![image-20210614144526769](media/images/image-20210614144526769.png)

二叉树有两种特殊的形式，一个叫做**满二叉树**，另一个叫做**完全二叉树**。  

**满二叉树：一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树。**  如下图所示，就是一个**满二叉树**。   

![image-20210614145443661](media/images/image-20210614145443661.png)

**完全二叉树：对于一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号从1到n的节点位置相同，则这个二叉树是完全二叉树。**  

![image-20210614145644012](media/images/image-20210614145644012.png)

在上图中，二叉树编号从1到12的12个节点，和前面满二叉树编号从1到12的节点位置完全对应。因此这个树是完全二叉树。  

##### 二叉树的存储结构  

**1：链式存储结构**

**2：数组**

链式存储结构如下图： 

![image-20210614145816876](media/images/image-20210614145816876.png)

二叉树的每一个节点包含三个部分

- 存储数据的data变量
- 指向左孩子的left指针
- 指向右孩子的right指针

数组存储方式如下图： 

![image-20210614145941222](media/images/image-20210614145941222.png)

使用数组存储时，会按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某一个节点的左孩子或者右孩子空缺，则数组的相应位置也空出来。因为这样设计可以方便地在数组中定位二叉树的孩子节点和父节点。  

假设一个父节点的下标是parent，那么它的左孩子节点下标就是 2xparent + 1；右孩子节点下标就是 2xparent + 2。反过来，假设一个左孩子节点的下标是leftChild，那么它的父节点下标就是（leftChild-1）/ 2。  

##### 二叉树的应用  

###### 1、查找  

一种特殊的二叉树：二叉查找树（binary search tree）。这种树的主要作用就是进行查找操作。二叉查找树在二叉树的基础上又增加了一下几个条件。  

- 如果左子树不为空，则左子树上所有节点的值均小于根节点的值 

- 如果右子树不为空，则右子树上所有节点的值均大于根节点的值 

- 左、右子树也都是二叉查找树

下图是一个标准的二叉查找树：

![image-20210614151108449](media/images/image-20210614151108449.png) 

例如我们要查找节点4,步骤如下：

（1）访问根节点，发现4<6，那么4在树的左侧。

（2）继续访问左侧的树，访问6的左孩子节点3，发现4>3。那么判断4在3的右侧。  

（3）访问3的右孩子节点4，发现4=4，查找结束。  

对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是n，那么搜索节点的时间复杂度就是 O(log n)，和树的深度是一样的。  （2为底）  

###### 2、维持相对秩序  

二叉查找树要求左子树小于父节点，右子树大于父节点，正是这样保证了二叉树的有序性。因此二叉查找树还有另一个名字------二叉排序树（binary sort tree）。  

新插入的节点，同样要遵循二叉排序树的原则。例如插入新元素5，由于5<6，5>3，5>4，所以5最终会插入到节点4的右孩子位置。  

![image-20210614152058546](media/images/image-20210614152058546.png)

再如插入新元素10，由于10>6，10>8，10>9，所以10最终会插入到 节点9的右孩子位置。

![image-20210614152133971](media/images/image-20210614152133971.png)

这一次看起来很顺利，然而却隐藏着一个致命的问题。如果在二叉查找树中一次插入9、8、7、6、5、4，看看会出现什么结果。  

![image-20210614152259851](media/images/image-20210614152259851.png)

查询节点的时间复杂度也退化成了O(n)。怎么解决这个问题呢？这就涉及二叉树的自平衡了。二叉树自平衡的方式有很种。如红黑树、AVL树、树堆等。除了二叉查找树以外，二叉堆也维持着相对的顺序。不过二叉堆的条件要宽松些，只要求父节点比它的左右孩子都大。  

##### 二叉树的遍历   

在计算机程序中，便利本身是一个线性操作。所以遍历同样具有线性结构的数组或链表，是一件轻而易举的事情。  

![image-20210614153112130](media/images/image-20210614153112130.png)

而二叉树，是典型的非线性数据结构，遍历时需要把非线性关联的节点转化成一个线性的序列，以不同的方式来遍历，遍历出的序列顺序也不同。  

从节点之间位置关系的角度来看，二叉树的遍历分为4种：  

**1、前序遍历**

**2、中序遍历**

**3、后序遍历**

**4、层序遍历**

从更宏观的角度来看，二叉树的遍历归结为两大类。  

**1、深度优先遍历（前序遍历、中序遍历、后序遍历）**

**2、广度优先遍历（层序遍历）**

##### 深度优先遍历  

所谓深度优先，顾名思义，就是偏向于纵深，“一头扎到底”的访问方式。  

**1、前序遍历**  

**二叉树的前序遍历，输出顺序是根节点、左子树、右子树。**

![image-20210614153524477](media/images/image-20210614153524477.png)

上图就是输入一个二叉树的前序遍历，每个节点左侧的序号代表节点的输出顺序。步骤：

（1）首先输出根节点1

（2）由于根节点**存在左孩子**，输出左孩子节点2

（3）由于节点2**也存在左孩子**，输出左孩子节点4

（4）节点4既没有左孩子，也没有右孩子，那么回到节点2，输出节点2的右孩子节点5.

（5）节点5既没有左孩子，也没有右孩子，那么回到节点1，输出节点1的右孩子节点3.  

（6）节点3没有左孩子，但是有右孩子，因此输出节点3的右孩子节点6.

到此为止，所有节点遍历输出完毕。  

**2、中序遍历**  

**二叉树的中序遍历，输出顺序是左子树、根节点、右子树。**

![image-20210614154049269](media/images/image-20210614154049269.png)

上图就是输入一个二叉树的中序遍历，每个节点左侧的序号代表节点的输出顺序。步骤：

（1）首先访问根节点的左孩子，如果这个左孩子还拥有左孩子，则继续深入访问下去，一直找到不再有左孩子的节点，并输出该节点。显 然，第一个没有左孩子的节点是节点4。

（2）依照中序遍历的次序，接下来输出节点4的父节点2。  

（3）再输出节点2的右孩子节点5。

（4）以节点2为根的左子树已经输出完毕，这时再输出整个二叉树的 根节点1。

（5）由于节点3没有左孩子，所以直接输出根节点1的右孩子节点3。

（6）最后输出节点3的右孩子节点6。

**3、后序遍历**

**二叉树的后序遍历，输出顺序是左子树、右子树、根节点。**

![image-20210614154417360](media/images/image-20210614154417360.png)

上图就是输入一个二叉树的中序遍历，每个节点左侧的序号代表节点的输出顺序。  

代码如下：

```java
package com.lanwq.data_structure_demo.demo;


import java.util.LinkedList;

import static java.util.Arrays.asList;

/**
 * @program: dataStructure->BinaryTreeTraversal
 * @description: 二叉树遍历
 * @author: lanwenquan
 * @date: 2021-06-14 16:21
 */
public class BinaryTreeTraversal {

    public static TreeNode createBinaryTree(LinkedList<Integer> inputList) {
        TreeNode node = null;
        if (inputList == null || inputList.isEmpty()) {
            return null;
        }
        Integer data = inputList.removeFirst();
        if (data != null) {
            node = new TreeNode(data);
            node.leftChild = createBinaryTree(inputList);
            node.rightChild = createBinaryTree(inputList);
        }
        return node;
    }

    /**
     * 二叉树前序遍历, 根节点，左子树，右子树
     */
    public static void preOrderTraversal(TreeNode node) {
        if (node == null) {
            return ;
        }
        // 根节点
        System.out.println(node.data);
        // 遍历左节点
        preOrderTraversal(node.leftChild);
        preOrderTraversal(node.rightChild);
    }

    /**
     * 二叉树中序遍历，左子树，根节点，右子树
     */
    public static void inOrderTraversal(TreeNode node) {
        if (node == null) {
            return ;
        }
        // 遍历左节点
        inOrderTraversal(node.leftChild);
        // 根节点
        System.out.println(node.data);
        inOrderTraversal(node.rightChild);
    }

    /**
     * 二叉树后序遍历，左子树，右子树，根节点
     */
    public static void postOrderTraversal(TreeNode node) {
        if (node == null) {
            return ;
        }
        // 遍历左节点
        postOrderTraversal(node.leftChild);
        // 遍历右节点
        postOrderTraversal(node.rightChild);
        // 根节点
        System.out.println(node.data);
    }

    private static class TreeNode {
        Integer data;
        TreeNode leftChild;
        TreeNode rightChild;

        TreeNode (Integer data) {
            this.data = data;
        }
    }

    public static void main(String[] args) {
        LinkedList<Integer> inputList = new LinkedList<>(asList(3, 2, 9, null, null, 10, null, null, 8, null, 4));
        TreeNode treeNode = createBinaryTree(inputList);
        System.out.println("前序遍历:");
        preOrderTraversal(treeNode);
        System.out.println("中序遍历：");
        inOrderTraversal(treeNode);
        System.out.println("后序遍历：");
        postOrderTraversal(treeNode);
    }
}

```

这是上面构建出来的二叉树

![image-20210614163721370](media/images/image-20210614163721370.png)

