#### 垃圾收集  

- **2 对象已死吗？**  
  - [2.1 引用计数算法](#2.1 引用计数算法)  
  - [2.2 可达性分析算法](#2.2 可达性分析算法)  
  - [2.3 再谈引用（四种引用）](#2.3 再谈引用)  
  - [2.4 不可达的对象，也并非是“非死不可”](#2.4 生存还是死亡)  
  - [2.5 回收方法区---回收”废弃的常量“](#2.5 回收废弃的常量)  
  - [2.6 回收方法区---回收“无用的类“](#2.6 回收无用的类)  
  
- **3 垃圾收集算法**  
  + [3.1 标记-清除算法](#3.1 标记-清除算法)  
  + [3.2 复制算法](#3.2 复制算法)  
  + [3.3 标记-整理算法](#3.3 标记-整理算法)  
  + [3.4 分代手机算法](#3.4 分代手机算法)   

- **4 HotSpot的算法实现**  

- **5 垃圾收集器**  
  
  - [5.1 Serial 收集器](#5.1 serial-收集器)
  - [5.2 ParNew 收集器](#5.2 parnew-收集器)
  - [5.3 Parallel Scavenge 收集器](#5.3 parallel-scavenge-收集器)
  - [5.4.Serial Old 收集器](#5.4 serial-old-收集器)
  - [5.5 Parallel Old 收集器](#5.5 parallel-old-收集器)
  - [5.6 CMS 收集器](#5.6 cms-收集器)
- [5.7 G1 收集器](#5.7 g1-收集器)
  
- **6 内存分配和回收策略**  

- **7 常用虚拟机回收参数**  

  



















##### **2 对象已死吗？**  

Java堆中存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“**存活**”着，哪些已经“**死去**”（即不可能再被任何途径使用的对象，***不能再被使用***）。  

##### 2.1 引用计数算法  

引用计数法是指：**给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的**。  

客观地说，引用计数算法（Reference Counting）的**实现简单，判定效率也很高**。但是，至少主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中主要的原因是**它很难解决对象之间相互循环引用的问题**。  

下面的代码中：对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。  

```Java
public class ReferenceCountingGc {
    public Object instance = null;
    private static final int MB = 1024 * 1024;

    public static void main(String[] args) {
        ReferenceCountingGc objA = new ReferenceCountingGc();
        ReferenceCountingGc objB = new ReferenceCountingGc();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
        // 添加虚拟机参数 -XX:+PrintGCDetails
        // 假设在这发生GC，objA,objB能否被回收
        System.gc();
    }
}
```

GC日志：  

```Java
[GC (System.gc()) [PSYoungGen: 7424K->904K(38400K)] 7424K->912K(125952K), 0.0011613 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 904K->0K(38400K)] [ParOldGen: 8K->783K(87552K)] 912K->783K(125952K), [Metaspace: 3497K->3497K(1056768K)], 0.0042891 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 PSYoungGen      total 38400K, used 333K [0x00000000d5d00000, 0x00000000d8780000, 0x0000000100000000)
  eden space 33280K, 1% used [0x00000000d5d00000,0x00000000d5d534a8,0x00000000d7d80000)
  from space 5120K, 0% used [0x00000000d7d80000,0x00000000d7d80000,0x00000000d8280000)
  to   space 5120K, 0% used [0x00000000d8280000,0x00000000d8280000,0x00000000d8780000)
 ParOldGen       total 87552K, used 783K [0x0000000081600000, 0x0000000086b80000, 0x00000000d5d00000)
  object space 87552K, 0% used [0x0000000081600000,0x00000000816c3d00,0x0000000086b80000)
 Metaspace       used 3504K, capacity 4498K, committed 4864K, reserved 1056768K
  class space    used 387K, capacity 390K, committed 512K, reserved 1048576K
```

从日志中可以看到`[PSYoungGen: 904K->0K(38400K)]`，意味着虚拟机并没有因为这两个对象互相引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的。  

##### 2.2 可达性分析算法  

在主流商用程序语言（Java、C#等）的主流实现中，都是通过**可达性分析（Reachability Analysis）**来判断对象是否存活的。这个算法的基本思路是**通过一系列的称为”GC Roots“的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的**。如下图所示：  

<img src="media/images/image-20201026215701896.png" alt="image-20201026215701896" style="zoom:67%;" />

在Java中，可以作为GC Roots的对象包括这几种：  

- 虚拟机栈（栈帧中的本地变量表）中引用的对象  
- 方法去中类静态属性引用的对象  
- 方法区中常量引用的对象  
- 本地方法栈中JNI（native方法）引用的对象  

##### 2.3 再谈引用  

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。

在JDK1.2以前，Java中的引用定义很传统：**如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用**。这种定义很纯粹，但是太过狭隘，**一个对象在这种定义下只有被引用或者没有被引用两种状态**，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。  

在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为**强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）**4种，这4种引用强度依次逐渐减弱。  

##### Java中的四种引用  

| 序号 | 引用类型 | 取得目标对象方式 | 垃圾回收条件   | 是否可能内存泄漏 |
| :--: | -------- | ---------------- | -------------- | ---------------- |
|  1   | 强引用   | 直接调用         | 不回收         | 可能             |
|  2   | 软引用   | 通多get()方法    | 视内存情况回收 | 不可能           |
|  3   | 弱引用   | 通过get()方法    | 永远回收       | 不可能           |
|  4   | 虚引用   | 无法取得         | 不回收         | 可能             |

- **强引用（StrongReference）**  

强引用就是值在程序代码中普片存在的，类似`Object obj = new Obect()`这类的引用，只要 **强引用还在，垃圾收集器永远不会回收掉被引用的对象**。  

- **软引用（SoftReference）**  

软引用是用来描述 **一些还有用但并非必需的对象**。对于软引用关联着的对象，**在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。**如果这次回收还没有足够的内存，才会抛出内存溢出异常。在jdk1.2之后提供了SoftReference。  

软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。  

用处：**适合用于缓存**。实例：  

```java
//示例1
SoftReference<String[]> softBean = new SoftReference<String[]>(new String[]{"a", "b", "c"});

//示例2
ReferenceQueue<String[]> referenceQueue = new ReferenceQueue<String[]>();
SoftReference<String[]> softBean = new SoftReference<String[]>(new String[]{"a", "b", "c"}, referenceQueue);
```

- **弱引用（WeakReference）**  

弱引用也是用来描述 **非必需的对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。**当垃圾收集器工作室，无论当前内存是否足够，都会回收掉被弱引用关联的对象。在jdk1.2之后提供了WeakReference。  

**弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中**。实例：  

```java
//示例1
WeakReference<String[]> weakBean = new WeakReference<String[]>(new String[]{"a", "b", "c"});
//示例2
ReferenceQueue<String[]> referenceQueue = new ReferenceQueue<String[]>();
WeakReference<String[]> softBean = new WeakReference<String[]>(new String[]{"a", "b", "c"}, referenceQueue);
```

- **虚引用（PhantomReference）**  

虚引用也称为幽灵引用或者幻影引用，他是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成印象，也无法通过虚引用来取得一个对象实例。  

**虚引用主要用来跟踪对象被垃圾回收器回收的活动**。虚引用与软引用和弱引用的一个区别在于：**虚引用必须和引用队列 （ReferenceQueue）联合使用**。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。  
 示例：

```java
ReferenceQueue<String[]> referenceQueue = new ReferenceQueue<String[]>();
PhantomReference<String[]> referent = new PhantomReference<String>(new String[]{"a", "b", "c"}, referenceQueue);
```

参考链接：

[https://juejin.im/post/6844903802378665997](https://juejin.im/post/6844903802378665997)    

##### 2.4 生存还是死亡  

即使在可达性分析算法中不可达的对象，也并非是“非死不可”的。这时候他们暂时处于“缓刑”的阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：**如果对象在进行可达性反洗后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”**。  

如果这个对象被判定有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。在GC对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己----只要重新与引用链上的任何一个对象建立关联即可（不然这个对象会被回收）。例如，把自己(this关键字)赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除“即将回收”的集合；如果对象这个时候还没有逃脱并拯救自己，那么基本上它就真的被回收了。  

##### 2.5 回收废弃的常量  

很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%～95%的空间，而永久代的垃圾收集效率远低于此。

- 废弃的常量  

回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面的回收为例，加入一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个"abc"常量就会被系统清理出常量池。**常量池中的其他类（接口）、方法、字段的符号引用也与此类似**。  

- 无用的类  

方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？

判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 **“无用的类”** ：

1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。

2. 加载该类的 ClassLoader 已经被回收。

3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就会必然被回收。