```java
	Java与C++之间有一堵由内存动态分配和    垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人想出来。
```
参考----《深入理解Java虚拟机，JVM高级特性与最佳实现》第二版

### 二、运行时数据区域

​	Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动二存在，有些区域则依赖用户线程的启动和结束而建立和销毁。参考《深入理解Java虚拟机》的图：

<img src="media/images/JVM运行时数据区.png" alt="JVM运行时数据区" style="zoom:50%;" />

#### 2.1  程序计数器（属于线程私有的内存空间）
​	程序计数器（Program Counter Register）是一块内存很小的内存空间，**它可以看作是当前线程所执行的字节码的行号指示器**。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），***字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令***，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

​	由于Java虚拟机的多线程是**通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。**因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存为“**线程私有**”的内存。

​	如果一个线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是一个native方法，这个计数器值则为空（undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError的情况的区域。

#### 2.2  Java虚拟机栈（也叫栈，属于Java线程私有的内存空间）

​	与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stack）**也是线程私有的**，它的生命周期和线程相同。虚拟机栈描述的是**Java方法的内存模型**：每个方法在执行的同时都会创建一个**栈帧**（stack Frame，方法运行时的基础数据结构），用于存放**局部变量表、操作数栈、动态链接、方法出口等信息。**每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中**入栈和出栈的过程**。

​	经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分发很粗糙，实际上Java内存区域的划分远比这复杂。其中所指的“**栈**”就是**虚拟机栈**，或者说是**虚拟机栈中的局部变量表部分**。

​	局部变量表存放了**编译器可知**的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（**reference类型，它不等同于对象本身，可能是一个指向起始地址的引用指针，也有可能是指向一个代表对象的句柄或其他与此对象相关的位置**）和return address类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（slot），企业的数据类型占用1个。局部变量表所需要的内存空间在编译器间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间时完全确定的，在这个方法的运行期间不会改变局部变量表的大小。

​	在虚拟机规范中，对这个区域规定了两种异常情况：如果线程请求的栈的深度大于虚拟机所允许的深度，将抛出StackOverflow Error异常；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出outofmemory异常。

#### 2.3  本地方法栈（也是属于Java线程私有的内存空间）
​	本地方法栈（native method stack）与虚拟机所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的native方法服务。（Sun HotSpot直接将本地方法栈和虚拟机栈合二为一，异常和虚拟机栈一样，都会抛出两个异常）。
#### 2.4  Java堆
​	Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。**Java堆是被所有线程共享的一块内存区域，在虚拟机创启动时创建**。内存区域的唯一目的就是**存放对象实例，几乎所有的对象实例都是在这里分配内存 **。这一点在虚拟机中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙变化发生，所有的对象都分配在堆上也不是那么绝对了。

​        Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Head）。从**内存回收的角度**来看，由于现在收集器基本都采用**分代收集算法**，所以Java堆中还可以分为：新生代和老年代；再细致一点的有**Eden空间、From Survivor空间、To Survivor空间等**。从**内存分配的角度**来看，线程共享的Java堆账可能划分出**多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）**。进一步划分的目的是为了更好的回收内存，或者更快的分配内存。

#### 2.5  方法区
　　方法区和Java堆一样，是各个线程共享的内存区域，它用于**存储已经被虚拟机加载的类的信息、常量、静态变量、即时编译器编译后的代码等数据**。虽然Java虚拟规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。

　　对于在HotSpot上开发的开发者来说，很多人称呼方法区为**永久代（Permanent Generation）**，本质上两者并不等价，仅仅是因为HotSpot虚拟机团队把GC分代收集扩展至方法区，或者说是使用永久代来实现方法区而已，这样就可以和管理堆一样来管理这部分内存，省区专门为方法区编写内存管理代码的工作。

#### 2.6  运行时常量池
　　运行时常量池（Runtime Constant Pool）是**方法区的一部分**。Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是**常量池（Constant Pool Table）**，作用是**用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载之后进入方法区的运行时常量池中存放。**

　　Java虚拟机对Class文件每一部分的格式（自然也包括常量池）都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需求来实现这个内存区域。

　　既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。

　　**JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**
　　![常量池包含内容](media/images/常量池包含内容.jpg)
　　参考---[图片链接](https://blog.csdn.net/wangbiao007/article/details/78545189)

#### 2.7  直接内存
　　**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。**

　　JDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。

### 三、HotSpot虚拟机对象探秘
　　在大致知道虚拟机的内存的概况之后，现在来了解数据是**如何创建、如何布局以及如何访问的。**以下来了解下Java堆中对象分配、布局和访问的全过程。
#### 3.1 对象的创建
　　我们创建对象（例如克隆、反序列化）通常仅仅是一个new关键字而已，而在虚拟机中，对象的创建是怎样的过程呢？
![image-20200926165551306](media/images/对象的创建过程.png)

**第一步：对象加载检查**
　　虚拟机遇到一条new指令的时候，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用（常量池中存放的是字面量和符号引用），并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那就执行类的加载和初始化过程。

**第二步：分配内存**
　　在类通过加载后，新生对象所需要的内存空间是完全确定了的，为对象分配空间的任务相当于把一块确定大小的内存从Java堆中划分出来。这个时候就有两种情况了。

　　第一种：**假设Java堆中的内存是绝对规整的**，所有用过的内存放一边和空闲的内存放置另一边，中间放着一个指针作为分界点的指示器，那所分配的内存仅仅是把那个指针向空闲空间移动一段与对象大小相等的距离，这种分配方式称为**“指针碰撞（Bump the Pointer）”**。　

　　第二种：如果**Java堆中的内存并不是规整**的，已使用的内存和空闲的内存相互交错，那就没有办法进行简单的指针碰撞了，虚拟机就必须维护一个列表，用来**记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，**这种分配方式称为**“空闲列表”**。**选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。**

　　因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。

**内存分配的两种方式：（补充内容，需要掌握）**   

　　选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。

**并发出现的问题**  
　　对象的创建是非常频繁的，即使是修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没有来的及修改，对象B又使用了原来的指针来分配内存的情况。解决方法：

  - **CAS+失败重试**：CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**

  - **TLAB**：为每一个线程预先分配一小块内存（本地内存缓冲区，TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上面分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定，再采用上述的的CAS进行内存分配。可以通过参数 -XX:+/-UseTLAB，来设定是否使用TLAB。

**第三步：初始化零值**  
　　内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。（所以静态变量可以不用创建类就可以使用）。  
**第四步：设置对象头**  
　　初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。**这些信息存放在对象的对象头（Object Header）之中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。  
**第五步：执行init()方法**  
　　在完成上面的工作之后，从虚拟机的角度来看，一个新的对象已经产生了，但是从Java程序的视角来看，对象创建才刚刚开始—`<init>`方法还没有执行，所有的字段都还为零（在上面已经将所有的字段初始化为了零值，字段对应）。 所以一般来说（由字节码中是否跟随invokespecial指令所决定），执行 new 指令之后会接着执行 `<init>`方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。  