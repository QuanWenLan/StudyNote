### 线程安全和锁优化

1 概述

2 线程安全

- 2.1 Java语言中的线程安全

  - 不可变
  - 线程绝对安全
  - 线程相对安全
  - 线程兼容
  - 线程对立

- 2.2 线程安全的实现方法


3 







---

> 并发处理的广泛应用是使得Amdahl定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。

---

#### 1 概述  

在软件业发展的初期，程序编写都是以算法为核心的，程序员会把**数据和过程分别作为独立的部分来考虑，数据代表问题空间中的客体，程序代码则用于处理这些数据，这种思维方式直接站在计算机的角度去抽象问题和解决问题，称为面向过程的编程思想**。与此相对的是，**面向对象的编程思想是站在现实世界的角度去抽象和解决问题，它把数据和行为都看做是对象的一部分，这样可以让程序员能以符合现实世界的思维方式来编写和组织程序**。

面向过程的编程思想极大地提升了现代软件开发的生产效率和软件可以达到的规模，但是现实世界与计算机世界之间不可避免地存在一些差异。例如，**人们很难想象现实中的对象在一项工作进行期间，会被不停地中断和切换，对象的属性（数据）可能会在中断期间被修改和变“脏”，而这些事件在计算机世界中则是很正常的事情**。有时候，良好的设计原则不得不向现实做出一些让步，我们必须让程序在计算机中正确无误地运行，然后再考虑如何将代码组织得更好，让程序运行得更快。对于这部分的主题“高效并发”来讲，**首先需要保证并发的正确性，然后在此基础上实现高效**。  

#### 2 线程安全  

线程安全定义：在《Java Concurrency In Practice》的作者Brian Goetz对“线程安全”有一个比较恰当的定义，**当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的**。   

这个定义要求线程安全的代码都必须具备一个特性：**代码本身封装了所有必要的正确性手段（如互斥同步等），令调用者无需多关心线程的问题，更无需自己采取任何措施来保证多线程的正确调用**。 （感觉是调用者只管调用，调用结果是正确的，代码有自己的手段保证正确性）。 这个听起来有点简单，但其实并不容易做到，在大多数场景中，我们都会将这定义弱化一些，如果把“调用这个对象的行为”限定为“单次调用”，这个定义的其他描述也能够成立的话，我们就可以称它为线程安全了，后面介绍为什么要弱化这个定义。  

#### 2.1 Java语言中的线程安全   

 我们这里讨论的线程安全，**就限定于多个线程之间存在共享数据访问这个前提**，因为如果一段代码根本不会与其他线程共享数据，那么从线程安全的角度来看，程序是串行还是多线程执行对它来说都是没有区别的。  

为了更加深入地理解线程安全，在这里我们可以不把线程安全当做一个非真即假的二元排他选项来看待，**按照线程安全的“安全程度”由强至弱来排序**，我们可以将Java语言中各种操作共享的数据分为以下5类：**不可变、绝对线程安全、相对线程安全、线程兼容和线程对立**。  

##### 2.1.1 不可变  

在Java语言中（特指JDK 1.5以后，即Java内存模型被修正之后的Java语言），**不可变（Immutable）的对象一定是线程安全的**，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施，在谈到**final关键字**带来的可见性时曾经提到过这一点，**只要一个不可变的对象被正确地构建出来（没有发生this引用逃逸的情况），那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程之中处于不一致的状态。“不可变”带来的安全性是最简单和最纯粹的**。  

Java语言中，如果共享数据类型是一个**基本数据类型**，那么只要在定义时使用`final`关键字修饰它就可以保证它是不可变的。    

如果共享数据类型是一个**对象**，那就**需要保证对象的行为不会对其状态产生任何影响才行**。例如：`java.long.String`类的对象，它是典型的一个*不可变*对象，我们调用它的`substring()、replace()和concat()`都不会影响它原来的值，只会返回一个新构造的字符串对象。  

保证对象行为（类比成对象调用方法）不影响自己状态的途径有很多种，其中最简单的就是把*对象中带有状态的变量都声明为final*，这样在构造函数结束之后，它就是不可变的。例如下面代码JDK中Integer的构造函数,：  

```java
public final class Integer extends Number implements Comparable<Integer> {
    ...
     /**
     * The value of the {@code Integer}.
     *
     * @serial
     */
    private final int value;

    /**
     * Constructs a newly allocated {@code Integer} object that
     * represents the specified {@code int} value.
     *
     * @param   value   the value to be represented by the
     *                  {@code Integer} object.
     */
    public Integer(int value) {
        this.value = value;
    }   
    ...
}
```

**它通过将内部状态变量value定义为final来保障状态不变**。  

JDK源码中还有其他的不可变要求的类型，除了`String`之外，常用的还有**枚举类型**，以及**`Java.long.Number`的部分子类，如Long和Double等数值包装类型**， `BigInteger和BigDecimal`等大数据类型；但同为Number的子类型的原子类`AtomicInteger和AtomicLon`g则并非不可变的，查看源码，思考下为什么。

##### 2.1.2 绝对线程安全  

绝对的线程安全完全满足**当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的**这个定义，一个类要达到“不管运行时环境如何，调用者都不需要做任何额外同步措施”通常需要付出很大的，甚至有时候是不切实际的代价。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。通过Java API中一个不是 “绝对线程安全”的线程安全类来看看这里的 “绝对” 的意思。  

如果说`java.util.Vector`是一个线程安全的容器，相信所有的Java程序员对此都不会有异议，因为它的add()、get()和size()这类方法都是被synchronized修饰的，尽管这样效率很低，但确实是安全的。但是，即使它所有的方法都被修饰成同步，也不意味着调用它的时候永远都不再需要同步手段了，如下面例子：  

```java 
private static Vector<Integer> vector = new Vector();

    public static void main(String[] args) {
        while (true) {
            for (int i = 0; i < 10; i++) {
                //往vector中添加元素
                vector.add(i);
            }

            Thread removeThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    //获取vector的大小
                    for (int i = 0; i < vector.size(); i++) {
                        //当前线程让出CPU,使例子中的错误更快出现
                        Thread.yield();
                        //移除第i个数据
                        vector.remove(i);
                    }
                }
            });

            Thread printThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    //获取vector的大小
                    for (int i = 0; i < vector.size(); i++) {
                        //当前线程让出CPU,使例子中的错误更快出现
                        Thread.yield();
                        //获取第i个数据并打印
                        System.out.println(vector.get(i));
                    }
                }
            });

            removeThread.start();
            printThread.start();
            //避免同时产生过多线程
            while (Thread.activeCount() > 20) ;
        }
    }
```
报错信息如下图：
![image](https://user-images.githubusercontent.com/38965675/115324635-c5d61f80-a1bc-11eb-9de1-25f950a67bdd.png)
解析：很明显，尽管这里使用到的`Vector`的`get()、remove()、size()`方法都是同步的，但是在多线程的环境中，如果不在方法调用段做额外的同步措施的话，使用这段代码仍然是不安全的，因为**孤弱另一个线程恰好在错误的时间里删除了一个元素，导致序号 i 已经不可再用的话，再用 i 访问数组就会抛出一个`ArrayIndexOutOfBoundsException`**。如果要保证这段代码能正确执行下去，我们要做如下修改：
```java
Thread removeThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    synchronized (vector) {
                        //获取vector的大小
                        for (int i = 0; i < vector.size(); i++) {
                            //当前线程让出CPU,使例子中的错误更快出现
                            Thread.yield();
                            //移除第i个数据
                            vector.remove(i);
                        }
                    }
                }
            });

            Thread printThread = new Thread(new Runnable() {

                @Override
                public void run() {
                    synchronized (vector) {
                        //获取vector的大小
                        for (int i = 0; i < vector.size(); i++) {
                            //当前线程让出CPU,使例子中的错误更快出现
                            Thread.yield();
                            //获取第i个数据并打印
                            System.out.println(vector.get(i));
                        }
                    }
                }

            });
```
参考博客：[链接](https://blog.csdn.net/zlp1992/article/details/50433778)

##### 2.1.3 线程相对安全    

相对的线程安全就是我们通常意义上所讲的线程安全，**它需要保证对这个对象单独的操作是线程安全的**，我们在调用的时候不需要做额外的保障措施，但是杜宇一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。  

在Java语言中，大部分的线程安全类都属于这种类型，例如`Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等`。  

##### 2.1.4 线程兼容  

线程兼容是值对象本身并不是线程安全的，但是**可以通过在调用端正确的使用同步手段来保证对象在并发环境下可以安全地使用**，我们**平常说的一个类不是线程安全的，绝大多数指的是这一种情况**。 Java API中大部分的类都属于线程兼容的，如与前面的`Vector和HashTable`对应的集合类`ArrayList和HashMap`等。  

##### 2.1.5 线程对立  

**线程对立是指无论调用端是否采取了同步措施，都无法在多线程的环境中并发使用的代码**。由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。  

一个线程对立的例子是Thread类的suspend()和resume()方法，如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的，如果suspend()中断的线程就是即将要执行resume()的那个线程，那就肯定要产生死锁了。也正是由于这个原因，suspend()和resume()方法已经被JDK声明废弃（@Deprecated）了。常见的线程对立的操作还有System. setIn()、Sytem.setOut()和System.runFinalizersOnExit()等。

#### 2.2 线程安全的实现方法  

了解了什么是线程安全之后，紧接着的一个问题就是我们应该如何实现线程安全？这听起来似乎是一件由代码如何编写来决定的事情，确实，如何实现线程安全与代码编写有很大的关系，但虚拟机提供的**同步机制和锁机制**也起到了非常重要的作用。  

##### 2.2.1 互斥同步  

**互斥同步（Mutual Exclusion & Synchronization）**（阻塞同步）是常见的一种并发正确性的保障手段。**同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个（或者是一些，使用信号量的时候）线程使用**。而**互斥是实现同步的一种手段**，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore)都是主要的互斥实现方式。在4个字里面，互斥是因，同步是果；互斥是方法，同步是目的。  

在Java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字经过编译之后，**会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象**。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或class对象来作为锁对象。  

根据虚拟机规范的要求，在执行monitorenter指令时，**首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就释放**。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。  

在虚拟机规范对monitorenter和monitorexit的行为描述中，有两点是需要特别注意的。**首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题**。其次，**同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入**。在前面的 [高效并发](./高效并发.md) 中有提到，Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从**用户态转换到核心态中**，因此状态转换需要耗费很多的处理器时间。对于代码简单的同步块（如被synchronized修饰的getter()或setter()方法），状态转换所消耗的时间有可能比用户代码执行的时间还要长。所以synchronized是Java语言中一个**重量级（Heavyweight）的操作**，在必要的情况下才使用这种操作。而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段**自旋等待过程，避免频繁地切入到核心态之中**。  

除了synchronized之外，我们还可以使用java.util.concurrent（J.U.C）包中的**重入锁（ReentrantLock）来实现同步**，在基本用法上，ReentrantLock与synchronized很相似，他们都具备一样的线程重入特性，只是代码写法有点区别。

一个表现为API层面的互斥锁（lock（）和unlock（）方法）配合try/finally语句来完成）

另一个表现为原生语法层面的互斥锁。  

不过相比于synchronized，ReentrantLock增加了一些高级功能，主要是以下3项：**等待可中断、可实现公平锁、锁可以绑定多个条件**。  

- 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。  
- 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是**非公平的**，**ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁**。  
- 锁绑定多个条件是指**一个ReentrantLock对象可以同时绑定多个Condition对象**，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newConditon()方法即可。  

如果需要使用到上面的三个高级功能，选择ReentrantLock是一个很好的选择，那如果基于性能考虑呢？在JDK1.6发布之后，synchronized和ReentrantLock的性能基本上是完全持平了。因此在JDK1.6或以上的版本编写程序，性能不再是选择ReentrantLock的理由了，虚拟机在未来的性能改进中肯定也会更加偏向于原生的synchronized，所以还是提倡**在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步**。  

##### 2.2.2 非阻塞同步  

**互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题**，因此这种同步也称为阻塞同步（Blocking Synchronization）。  从处理问题的方式上来说，**互斥同步是一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题**，无论共享数据是否真的会出现竞争，他都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。  

随着硬件指令集的发展，我们有了另一种的选择：**基于冲突检测的乐观并发策略**，通俗的说，就是先进行操作，如果没有其他线程争用共享数据，那就操作成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为**非阻塞同步**。  

为什么说乐观并发策略需要“硬件指令集的发展”才能进行呢？因为我们需要**操作和冲突检测这两个步骤具备原子性**，靠什么来保证呢？如果这里再使用互斥同步来保证就失去意义了，所以我们只能靠硬件来完成这件事情，硬件保证一个从语义 上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有：

- **测试并设置（Test-and-Set）**
- **获取并增加（Fetch-and-Increment）**
- **交换（Swap）**
- **比较交换（Compare-and-Swap，称为CAS）**
- **加载链接/条件存储（Load-Linked/Store-Conditional，称为LL/SC）**

CAS操作原理：

CAS指令需要有3个操作数，分别是**内存位置**（在Java中可以简单理解为变量的内存地址，用V表示）、**旧的预期值**（用A表示）和**新值**（用B表示）。CAS指令执行时，**当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值**，上述的处理过程是一个原子操作。

