### 线程安全和锁优化

1 概述

2 线程安全

- 2.1 Java语言中的线程安全

  - 不可变
  - 线程绝对安全
  - 线程相对安全
  - 线程兼容
  - 线程对立

- 2.2 线程安全的实现方法


3 







---

> 并发处理的广泛应用是使得Amdahl定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。

---

#### 1 概述  

在软件业发展的初期，程序编写都是以算法为核心的，程序员会把**数据和过程分别作为独立的部分来考虑，数据代表问题空间中的客体，程序代码则用于处理这些数据，这种思维方式直接站在计算机的角度去抽象问题和解决问题，称为面向过程的编程思想**。与此相对的是，**面向对象的编程思想是站在现实世界的角度去抽象和解决问题，它把数据和行为都看做是对象的一部分，这样可以让程序员能以符合现实世界的思维方式来编写和组织程序**。

面向过程的编程思想极大地提升了现代软件开发的生产效率和软件可以达到的规模，但是现实世界与计算机世界之间不可避免地存在一些差异。例如，**人们很难想象现实中的对象在一项工作进行期间，会被不停地中断和切换，对象的属性（数据）可能会在中断期间被修改和变“脏”，而这些事件在计算机世界中则是很正常的事情**。有时候，良好的设计原则不得不向现实做出一些让步，我们必须让程序在计算机中正确无误地运行，然后再考虑如何将代码组织得更好，让程序运行得更快。对于这部分的主题“高效并发”来讲，**首先需要保证并发的正确性，然后在此基础上实现高效**。  

#### 2 线程安全  

线程安全定义：在《Java Concurrency In Practice》的作者Brian Goetz对“线程安全”有一个比较恰当的定义，**当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的**。   

这个定义要求线程安全的代码都必须具备一个特性：**代码本身封装了所有必要的正确性手段（如互斥同步等），令调用者无需多关心线程的问题，更无需自己采取任何措施来保证多线程的正确调用**。 （感觉是调用者只管调用，调用结果是正确的，代码有自己的手段保证正确性）。 这个听起来有点简单，但其实并不容易做到，在大多数场景中，我们都会将这定义弱化一些，如果把“调用这个对象的行为”限定为“单次调用”，这个定义的其他描述也能够成立的话，我们就可以称它为线程安全了，后面介绍为什么要弱化这个定义。  

#### 2.1 Java语言中的线程安全   

 我们这里讨论的线程安全，**就限定于多个线程之间存在共享数据访问这个前提**，因为如果一段代码根本不会与其他线程共享数据，那么从线程安全的角度来看，程序是串行还是多线程执行对它来说都是没有区别的。  

为了更加深入地理解线程安全，在这里我们可以不把线程安全当做一个非真即假的二元排他选项来看待，**按照线程安全的“安全程度”由强至弱来排序**，我们可以将Java语言中各种操作共享的数据分为以下5类：**不可变、绝对线程安全、相对线程安全、线程兼容和线程对立**。  

#### 1 不可变  

在Java语言中（特指JDK 1.5以后，即Java内存模型被修正之后的Java语言），**不可变（Immutable）的对象一定是线程安全的**，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施，在谈到**final关键字**带来的可见性时曾经提到过这一点，**只要一个不可变的对象被正确地构建出来（没有发生this引用逃逸的情况），那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程之中处于不一致的状态。“不可变”带来的安全性是最简单和最纯粹的**。  

Java语言中，如果共享数据类型是一个**基本数据类型**，那么只要在定义时使用`final`关键字修饰它就可以保证它是不可变的。    

如果共享数据类型是一个**对象**，那就**需要保证对象的行为不会对其状态产生任何影响才行**。例如：`java.long.String`类的对象，它是典型的一个*不可变*对象，我们调用它的`substring()、replace()和concat()`都不会影响它原来的值，只会返回一个新构造的字符串对象。  

保证对象行为（类比成对象调用方法）不影响自己状态的途径有很多种，其中最简单的就是把*对象中带有状态的变量都声明为final*，这样在构造函数结束之后，它就是不可变的。例如下面代码JDK中Integer的构造函数,：  

```java
public final class Integer extends Number implements Comparable<Integer> {
    ...
     /**
     * The value of the {@code Integer}.
     *
     * @serial
     */
    private final int value;

    /**
     * Constructs a newly allocated {@code Integer} object that
     * represents the specified {@code int} value.
     *
     * @param   value   the value to be represented by the
     *                  {@code Integer} object.
     */
    public Integer(int value) {
        this.value = value;
    }   
    ...
}
```

**它通过将内部状态变量value定义为final来保障状态不变**。  

JDK源码中还有其他的不可变要求的类型，除了`String`之外，常用的还有**枚举类型**，以及**`Java.long.Number`的部分子类，如Long和Double等数值包装类型**， `BigInteger和BigDecimal`等大数据类型；但同为Number的子类型的原子类`AtomicInteger和AtomicLon`g则并非不可变的，查看源码，思考下为什么。

#### 2 绝对线程安全  

绝对的线程安全完全满足**当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的**这个定义，一个类要达到“不管运行时环境如何，调用者都不需要做任何额外同步措施”通常需要付出很大的，甚至有时候是不切实际的代价。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。通过Java API中一个不是 “绝对线程安全”的线程安全类来看看这里的 “绝对” 的意思。  

如果说`java.util.Vector`是一个线程安全的容器，相信所有的Java程序员对此都不会有异议，因为它的add()、get()和size()这类方法都是被synchronized修饰的，尽管这样效率很低，但确实是安全的。但是，即使它所有的方法都被修饰成同步，也不意味着调用它的时候永远都不再需要同步手段了，如下面例子：  

```java 
private static Vector<Integer> vector = new Vector();

    public static void main(String[] args) {
        while (true) {
            for (int i = 0; i < 10; i++) {
                //往vector中添加元素
                vector.add(i);
            }

            Thread removeThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    //获取vector的大小
                    for (int i = 0; i < vector.size(); i++) {
                        //当前线程让出CPU,使例子中的错误更快出现
                        Thread.yield();
                        //移除第i个数据
                        vector.remove(i);
                    }
                }
            });

            Thread printThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    //获取vector的大小
                    for (int i = 0; i < vector.size(); i++) {
                        //当前线程让出CPU,使例子中的错误更快出现
                        Thread.yield();
                        //获取第i个数据并打印
                        System.out.println(vector.get(i));
                    }
                }
            });

            removeThread.start();
            printThread.start();
            //避免同时产生过多线程
            while (Thread.activeCount() > 20) ;
        }
    }
```
报错信息如下图：
![image](https://user-images.githubusercontent.com/38965675/115324635-c5d61f80-a1bc-11eb-9de1-25f950a67bdd.png)
解析：很明显，尽管这里使用到的`Vector`的`get()、remove()、size()`方法都是同步的，但是在多线程的环境中，如果不在方法调用段做额外的同步措施的话，使用这段代码仍然是不安全的，因为**孤弱另一个线程恰好在错误的时间里删除了一个元素，导致序号 i 已经不可再用的话，再用 i 访问数组就会抛出一个`ArrayIndexOutOfBoundsException`**。如果要保证这段代码能正确执行下去，我们要做如下修改：
```java
Thread removeThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    synchronized (vector) {
                        //获取vector的大小
                        for (int i = 0; i < vector.size(); i++) {
                            //当前线程让出CPU,使例子中的错误更快出现
                            Thread.yield();
                            //移除第i个数据
                            vector.remove(i);
                        }
                    }
                }
            });

            Thread printThread = new Thread(new Runnable() {

                @Override
                public void run() {
                    synchronized (vector) {
                        //获取vector的大小
                        for (int i = 0; i < vector.size(); i++) {
                            //当前线程让出CPU,使例子中的错误更快出现
                            Thread.yield();
                            //获取第i个数据并打印
                            System.out.println(vector.get(i));
                        }
                    }
                }

            });
```
参考博客：[链接](https://blog.csdn.net/zlp1992/article/details/50433778)

#### 3 线程相对安全    

相对的线程安全就是我们通常意义上所讲的线程安全，**它需要保证对这个对象单独的操作是线程安全的**，我们在调用的时候不需要做额外的保障措施，但是杜宇一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。  

在Java语言中，大部分的线程安全类都属于这种类型，例如`Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等`。  

#### 4 线程兼容  

线程兼容是值对象本身并不是线程安全的，但是**可以通过在调用端正确的使用同步手段来保证对象在并发环境下可以安全地使用**，我们**平常说的一个类不是线程安全的，绝大多数指的是这一种情况**。 Java API中大部分的类都属于线程兼容的，如与前面的`Vector和HashTable`对应的集合类`ArrayList和HashMap`等。  

#### 5 线程对立  

**线程对立是指无论调用端是否采取了同步措施，都无法在多线程的环境中并发使用的代码**。由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。  

一个线程对立的例子是Thread类的suspend()和resume()方法，如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的，如果suspend()中断的线程就是即将要执行resume()的那个线程，那就肯定要产生死锁了。也正是由于这个原因，suspend()和resume()方法已经被JDK声明废弃（@Deprecated）了。常见的线程对立的操作还有System. setIn()、Sytem.setOut()和System.runFinalizersOnExit()等。

