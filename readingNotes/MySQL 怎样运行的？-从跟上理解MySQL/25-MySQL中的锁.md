### 25 锁

#### 1 解决并发事务带来的问题的两种基本方式

并发事务访问相同记录大致可分为3种情况：

##### 读-读 情况：

即并发事务相继读取相同的记录。读取操作不会对记录产生问题，所以不会引起什么问题。

##### 写-写 情况：

即并发事务相继对相同的记录做出改动。

我们前边说过，在这种情况下会发生 脏写 的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，**这个排队的过程其实是通过 锁 来实现的**。这个所谓的 锁 其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有 锁结构 和记录进行关联的，如图所示：
![image-20220121143028094](media/images/image-20220121143028094.png)

**当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的 锁结构 ，当没有的时候就会在内存中生成一个 锁结构 与之关联**。比方说事务 T1 要对这条记录做改动，就需要生成一个 锁结构 与之关联：

![image-20220121143112535](media/images/image-20220121143112535.png)

其实在 锁结构 里有很多信息，不过为了简化理解，我们现在只把两个比较重要的属性拿了出来：

- trx信息 ：代表这个锁结构是哪个事务生成的。
- is_waiting ：代表当前事务是否在等待。

如图所示，当事务 T1 改动了这条记录后，就生成了一个 锁结构 与该记录关联，因为之前没有别的事务为这条记录加锁，所以 **is_waiting 属性就是 false ，我们把这个场景就称之为获取锁成功，或者加锁成功**，然后就可以继续执行操作了。

在事务 T1 提交之前，另一个事务 T2 也想对该记录做改动，那么先去看看有没有 锁结构 与这条记录关联，发现有一个 锁结构 与之关联后，然后也生成了一个 锁结构 与这条记录关联，不过 **锁结构 的is_waiting 属性值为 true ，表示当前事务需要等待，我们把这个场景就称之为获取锁失败，或者加锁失败，或者没有成功的获取到锁**，画个图表示就是这样:
![image-20220121143236476](media/images/image-20220121143236476.png)

在事务 T1 提交之后，就会把该事务生成的 锁结构 释放掉，然后看看还有没有别的事务在等待获取锁，发现了事务 T2 还在等待获取锁，所以把事务 T2 对应的锁结构的 is_waiting 属性设置为 false ，然后把该事务对应的线程唤醒，让它继续执行，此时事务 T2 就算获取到锁了。效果图就是这样:

![image-20220121143300910](media/images/image-20220121143300910.png)

总结一下后面内容可能用到的几种说法：

- 不加锁：意思就是不需要在内存中生成对应的 锁结构 ，可以直接执行操作。
- 获取锁成功或者加锁成功：意思就是**在内存中生成了对应的 锁结构** ，而且**锁结构的 is_waiting 属性为 false** ，也就是事务可以继续执行操作。
- 获取锁失败，或者加锁失败，或者没有获取到锁：意思就是**在内存中生成了对应的 锁结构** ，不过**锁结构的is_waiting 属性为 true** ，也就是事务需要等待，不可以继续执行操作。

##### 读-写 或 写-写 情况：

也就是一个事务进行读取操作，另一个进行改动操作。我们前边说过，这种情况下可能发生 脏读 、 不可重复读 、 幻读 的问题。

怎么解决 脏读 、 不可重复读 、 幻读 这些问题呢？其实有两种可选的解决方案：

- 方案一：读操作利用多版本并发控制（MVCC)，写操作进行 加锁。
- 方案二：读、写操作都采用加锁方式

如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本，比方在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候也就需要对其进行 加锁 操作，这样也就意味着 读 操作和 写 操作也像 写-写 操作那样排队执行。

很明显，采用 MVCC 方式的话， 读-写 操作彼此并不冲突，性能更高，采用 加锁 方式的话， 读-写 操作彼此需要排队执行，影响性能。一般情况下我们当然愿意采用 MVCC 来解决 读-写 操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用 加锁 的方式执行，那也是没有办法的事。