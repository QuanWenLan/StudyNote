### 如何写出高性能SQL语句？

#### 慢 SQL 语句的几种常见诱因

##### 1 无索引、索引失效导致慢查询

##### 2 锁等待

可以看《MySQL 45讲中》中的  **为什么我只查一行的语句，也执行这么慢？**

##### 3 **不恰当的** **SQL** **语句**

使用不恰当的 SQL 语句也是慢 SQL 最常见的诱因之一。例如，习惯使用 <SELECT *>，<SELECT COUNT(*)> SQL 语句，在大数据表中使用 <LIMIT M,N> 分页查询，以及对非索引字段进行排序等等。

#### 优化SQL语句的步骤

参考sql的相关笔记：D:\projects\StudyNote\docs\面试\面试题-数据库.md  SQL优化、MySQL的explain解读

#### 常用 SQL 优化

##### 1 优化分页查询

通常我们是使用 <LIMIT M,N> + 合适的 order by 来实现分页查询，这种实现方式在没有任何索引条件支持的情况下，需要做大量的文件排序操作（file sort），性能将会非常得糟糕。如果有对应的索引，通常刚开始的分页查询效率会比较理想，但越往后，分页查询的性能就越差。

这是因为我们在使用 LIMIT 的时候，偏移量 M 在分页越靠后的时候，值就越大，数据库检索的数据也就越多。例如 LIMIT 10000,10 这样的查询，数据库需要查询 10010 条记录，最后返回 10 条记录。也就是说将会有 10000 条记录被查询出来没有被使用到。

##### 2 优化 count(*)

如果对一张大表经常做 SELECT COUNT(*) 操作，这肯定是不明智的。那么我们该如何对大表的 COUNT() 进行优化呢？

**使用近似值**

-- 使用SHOW TABLE STATUS命令来获取表的近似行数
SHOW TABLE STATUS LIKE 'table_name';

**增加汇总统计**

如果需要一个精确的 COUNT 值，我们可以额外新增一个汇总统计表或者缓存字段来统计需要的 COUNT 值，这种方式在新增和删除时有一定的成本，但却可以大大提升 COUNT()的性能。

##### 3 优化 select *

#### 开启慢查询

```mysql
Show variables like 'slow_query%';
Show variables like 'long_query_time';
```

如果没有开启，我们可以通过以下设置来开启：

```mysql
set global slow_query_log='ON'; // 开启慢 SQL 日志
set global slow_query_log_file='/var/lib/mysql/test-slow.log';// 记录日志地址
set global long_query_time=1;// 最大执行时间
```

假设有一张订单表 order，主要包含了主键订单编码 order_no、订单状态 status、提交时间 create_time 等列，并且创建了 status 列索引和 create_time 列索引。此时通过创建时间降序获取状态为 1 的订单编码，以下是具体实现代码：

`select order_no from order where status =1 order by create_time desc`

你知道其中的问题所在吗？我们又该如何优化？

为了避免文件排序的发生。因为查询时我们只能用到status索引，如果要对create_time 进行排序，则需要使用文件排序filesort。建立一个联合索引，包含 `status` 和 `create_time` 列，这样 MySQL 就可以利用这个索引完成排序操作，而不必再对 `create_time` 列进行排序。

